// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Banks');
gettext('Bus');
gettext('Machines');
gettext('MapIO');
gettext('ROM');
gettext('SMemory');
gettext('SMemory-Dual');
gettext('SMemory-str');
gettext('Smemory-Boot');
gettext('01-bit-regs');
gettext('02-bits-regs');
gettext('08-bits-regs');
gettext('Blocks');
gettext('Bank-2x1-paralell');
gettext('Bank of 2 registers of 1 bits (implemented in verilog). Addition output in paralell');
gettext('Bank-2x1');
gettext('Bank of 2 registers of 1 bits (implemented in verilog)');
gettext('Bank-4x1-paralell');
gettext('Bank of 4 registers of 1 bits with paralell output (implemented in verilog)');
gettext('Bank-4x1');
gettext('Bank of 4 registers of 1 bits (implemented in verilog)');
gettext('Bank-8x1-paralell');
gettext('Bank of 8 registers of 1 bits with paralell output (implemented in verilog)');
gettext('Bank-8x1');
gettext('Bank of 8 registers of 1 bits (implemented in verilog)');
gettext('Bank-2x1-paralell');
gettext('Bank of 2 registers of 1 bits with aditional output in paralell (implemented with blocks)');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('Multiplexor de 2 a 1');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('DFF. D Flip-flop. Verilog implementation');
gettext('1-bit register  \nAddress: 1');
gettext('1-bit register  \nAddress: 0');
gettext('Select the output  \naccording to the address');
gettext('Write the data to the regs  \nlocated in address addr');
gettext('1-2 demux');
gettext('Output in paralell');
gettext('Bank-2x1');
gettext('Bank of 2 registers of 1 bits (implemented with blocks)');
gettext('Bank-4x1-paralell');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('4-1 Mux. Sel is a bus');
gettext('Bus4-Join-all: Join all the wires into a 4-bits Bus');
gettext('1-4 demux');
gettext('1-bit register  \nAddress: 3');
gettext('1-bit register  \nAddress: 2');
gettext('Bank-4x1');
gettext('Bank of 4 registers of 1 bits (implemented with blocks)');
gettext('Bank-8x1-paralell');
gettext('Bank of 8 registers of 1 bits with paralell output (implemented with blocks)');
gettext('Separador de bus de 3-bits, en dos de 1 y 2 bits');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Bank 1');
gettext('4x1 Reg Bank');
gettext('Select the output  \nof the Bank (0/1)');
gettext('Bank selection  \n1: Bank 1  \n0: Bank 0  ');
gettext('Bank 0');
gettext('Divide the addr into two fields:  \n* Bank: Select the bank (0/1)  \n* Register inside the bank (0-3)');
gettext('Output in paralell  \n(Reg: 0-7)');
gettext('Bank-8x1');
gettext('Bank of 8 registers of 1 bits (implemented with blocks)');
gettext('bank-2x2');
gettext('Bank of 2 registers of 2 bits');
gettext('2-bits 4-1 Mux (The selection is a bus)');
gettext('02-Reg: 2 bits Register. Verilog implementation');
gettext('Blocks');
gettext('bank-2x8');
gettext('Bank of 2 registers of 8 bits (implemented in verilog)');
gettext('bank-4x8');
gettext('Bank of 4 registers of 8 bits (implemented in verilog)');
gettext('bank-8x8');
gettext('Bank of 8 registers of 8 bits (implemented in verilog)');
gettext('bank-2x8');
gettext('Bank of 2 registers of 8 bits (implemented with blocks)');
gettext('08-Reg: 8 bits Register. Verilog implementation');
gettext('2-to-1 Multplexer (8-bit channels). Verilog implementation');
gettext('8-bit register  \nAddress: 1');
gettext('8-bit register  \nAddress: 0');
gettext('bank-4x8');
gettext('Bank of 4 registers of 8 bits (implemented with blocks)');
gettext('Multiplexor de 4 a 1 de 8 bits');
gettext('8-bit register  \nAddress: 2');
gettext('8-bit register  \nAddress: 3');
gettext('bank-8x8');
gettext('Bank of 8 registers of 8 bits (implemented with blocks)');
gettext('4x8 Bank (0)');
gettext('Select the 4x8 bank');
gettext('4x8 Bank (1)');
gettext('Bytes');
gettext('16B');
gettext('2B');
gettext('4B');
gettext('8B');
gettext('Join');
gettext('Join the fields into one 16B memory bus');
gettext('split');
gettext('Split a 16B memory bus into its fields');
gettext('Join');
gettext('Join the fields into one 2B memory bus');
gettext('Split');
gettext('Split a 2B memory bus into its fields');
gettext('Join');
gettext('Join the fields into one 4B memory bus');
gettext('Split');
gettext('Split a 4B memory bus into its fields');
gettext('Join');
gettext('Join the fields into one 8B memory bus');
gettext('split');
gettext('Split a 8B memory bus into its fields');
gettext('Bytes');
gettext('16B');
gettext('2B');
gettext('4B');
gettext('8B');
gettext('download');
gettext('16B memory download machine');
gettext('Un bit constante a 0');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Puerta NOT');
gettext('Puerta AND');
gettext('Puerta OR');
gettext('Máquina de contar, de 4 bits');
gettext('Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 4 bits');
gettext('Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Biestable de almacenamiento del estado de la máquina');
gettext('RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog');
gettext('Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation');
gettext('NOT gate (Verilog implementation)');
gettext('Two bits input And gate');
gettext('System - D Flip-flop. Capture data every system clock cycle. Verilog implementation');
gettext('Falling-edge detector. It generates a 1-period pulse (tic) when a falling edge is detected on the input');
gettext('04-Reg-rst: 4 bits Register with reset. Verilog implementation');
gettext('8bits constant value: 0');
gettext('Generic: 8-bits generic constant (0-255)');
gettext('Transmit one character to the STDOUT bus');
gettext('Extract the next signal from the stdout bus');
gettext('stdout bus joiner (data + tic)');
gettext('2-to-1 Multplexer (10-bit channels). Verilog implementation');
gettext('2-to-1 Multplexer (14-bit channels). Verilog implementation');
gettext('Reading data from memory  \nReading bus status');
gettext('Calculate if the bus can be taken');
gettext('The bus is available');
gettext('This circuits wants  \nto use the bus');
gettext('The bus has been already  \ntaken');
gettext('One cycle after the machine is done  \nthe bus is already taken to write  \nthe bbusy signal to 0 and allow  \nother circuits to use it');
gettext('The output bus is controlled  \nby this circuit (1) or  \nremain untouched (0)');
gettext('The reading machine  \ncan be started');
gettext('Reading machine');
gettext('## Download machine\n\nTransmit all the memory contents through the serial port  \nThe bytes are transmited raw (in binary). No ascii encoding  \nThere should be a program running on the computer capable of  \nreading these raw bytes');
gettext('**Reloj del sistema**');
gettext('**Estado de**  \n**la máquina**');
gettext('Máquina encendida');
gettext('Máquina apagada  \n(rst = 1)');
gettext('Tic de arranque');
gettext('Tic de fin');
gettext('**Contador de ciclos**');
gettext('Número de ciclos  \ncontados');
gettext('Valor  \nincrementado');
gettext('### Salidas');
gettext('Estado de la máquina');
gettext('Ciclo actual');
gettext('Cuenta finalizada');
gettext('Ejecutar el ciclo');
gettext('Número de ciclos  \na contar');
gettext('¿Estamos en el  \nciclo k-1?');
gettext('Solo se hace caso a la  \nentrada next si la  \nmáquina está encendida');
gettext('Nuevo ciclo');
gettext('Si es el ciclo k-1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Apagar la  \nmáquina');
gettext('Ciclo nuevo:  \nincrementar la cuenta');
gettext('El tic de start se saca  \npor exec para que se ejecute  \nel primer ciclo');
gettext('Si la máquina está  \napagada, las señales  \nde ejecución no pueden  \nsalir!');
gettext('Retrasar la señal un ciclo  \nmientras que se detecta si  \nla máquina ha finalizado o no');
gettext('**Tic de apagado**');
gettext('**Tic de encendido**');
gettext('**Inicializar**');
gettext('**Estado de la máquina**');
gettext('## Rising edge detector\n\nIt generates a 1-period pulse (tic) when a rising edge is detected on the  \ninput signal');
gettext('Input signal');
gettext('System clock');
gettext('Current signal  \nstate');
gettext('Signal state in the previous  \nclock cycle');
gettext('If the current signal is 1 and its value in  \nthe previous clock cycle was 0, it means  \nthat a rising edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a rising edge  \nand its detection');
gettext('Input');
gettext('Output');
gettext('Parameter: Initial value');
gettext('Input data');
gettext('# D Flip-Flop  (system)\n\nIt stores the input data that arrives at cycle n  \nIts output is shown in the cycle n+1');
gettext('Not connected');
gettext('## Falling edge detector\n\nIt generates a 1-period pulse (tic) when a falling edge is detected on the  \ninput signal');
gettext('If the current signal is 0 and its value in  \nthe previous clock cycle was 1, it means  \nthat a falling edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a falling edge  \nand its detection');
gettext('## PUTC: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification    \n\nWhen the machine starts, the char is outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The byte from the  \ninput char is transmited');
gettext('Char to be transmited');
gettext('State of the machine:  \n1: ON: transmitting  \n2: OFF: transparent mode  ');
gettext('If the machine is on  \nand the character has been  \ntransmitted: Turn it off');
gettext('The machine has finished');
gettext('**STDOUT BUS**');
gettext('**Create the bus**  \nfrom the data and tic signals');
gettext('Transparent mode...  \nor not');
gettext('dump-tx');
gettext('16B Memory dump tx machine');
gettext('Serial transmiter for the stdout bus, with sysclk parameter');
gettext('stdout bus splitter into data and tic signals');
gettext('Convert the 1-bit next signal into a 10-bit stdout bus');
gettext('Serial transmitter with system clock freq parameter');
gettext('16B memory dump machine');
gettext('4bits constant value: 0');
gettext('Generic: 4-bits generic constant (0-15)');
gettext('Print a constant string of 63 or less characters');
gettext('Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro');
gettext('Un bit constante a 1');
gettext('Máquina de contar, de 6 bits, con entrada de stop');
gettext('6-bits adder. One operand is a constant (no carry)');
gettext('two operand 6-bits comparator');
gettext('Valor genérico constante (menos 1), de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('06-Reg-rst: 6 bits Register with reset. Verilog implementation');
gettext('64-bytes memory, initilized with a string');
gettext('Print a constant string of 3 or less characters');
gettext('Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)');
gettext('Sumador de un operando de 2 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 2 bits');
gettext('Valor genérico constante (menos 1), de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('02-Reg-rst: 2 bits Register with reset. Verilog implementation');
gettext('4-bytes memory, initilized with a string');
gettext('Print a byte in hexadecimal numbers');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('Mach-count-1-bit: 1-bit count machine');
gettext('OR2: Two bits input OR gate');
gettext('1-to-2 DeMultplexer (1-bit channels)');
gettext('TFF-verilog. System TFF with toggle input: It toogles on every system cycle if the input is active. Verilog implementation');
gettext('Transmit a 4-bits hex number (characteres 0 - 9, a - f)');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('Separador de bus de 4-bits en 4 cables');
gettext('Agregador de 4 cables en un bus de 4-bits');
gettext('Valor genérico constante, de 1 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Comparador menor que, de un operando de 4 bits');
gettext('2-to-1 Multplexer (4-bit channels). Verilog implementation');
gettext('Print a constant string of 7 or less characters');
gettext('Máquina de contar, de 3 bits, con stop');
gettext('Comparador de dos operandos de 3 bits');
gettext('Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('03-Reg-rst: 3 bits Register with reset. Verilog implementation');
gettext('8-bytes memory, initilized with a string');
gettext('## STDOUT serial\n\nSerial transmitter for the STDOUT bus\n');
gettext('**STDOUT Bus**  \n* Data to transmit (8 bits)  \n* tic (1 bit)\n* data sent (done tic, 1 bit)');
gettext('This circuit wants  \nto use the bus');
gettext('count machine');
gettext('## Print each entry of the table');
gettext('## Dump machine\n\nDump the contents of the memory to the serial port  \nThe data is shown in Hexadecimal ASCII\n\nExample:\n\n```\n| Addr | Data |\n|------|------|\n| 00   | 03   |\n| 01   | 0F   |\n| 02   | 3F   |\n| 03   | FF   |\n| 04   | FC   |\n| 05   | F0   |\n| 06   | C0   |\n| 07   | 00   |\n```\n...\n');
gettext('## PRINT: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification     \n\nWhen the machine starts, the first chars outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The transmision of  \nthe bytes is started');
gettext('Transmit the next  \ncharacter from the string');
gettext('Tic output: Execute!');
gettext('Count machine. It is counting  \nuntil the stop signal is  \nactivated');
gettext('If the character read is 0  \nwe have reached the end of  \nthe string');
gettext('Memory with the string  \nto be transmited');
gettext('Apagado automática,  \ncuando la máquina  \ntermina');
gettext('Apagado manual');
gettext('Para automático de la  \nmáquina cuando ha terminado  ');
gettext('Paro externo');
gettext('First the MSB is  \nprinter, then the LSB');
gettext('Bit to print:  \n0: Bit 0  \n1: Bit 1');
gettext('2-state machine  \nTwo operation are needed');
gettext('Print the current  \nhex digit');
gettext('Store the nunmber  \nto print');
gettext('Number to print');
gettext('Transmit now! (tic)  \nActivate the machine');
gettext('## PUTC-base4-bin: Transmit one base-4 number in Binary\n\nWhen activated, the base-4 number is sent as two binary  \ncharacters (0/1)');
gettext('If the machine is active, no more start signals  \nare allowed to enter');
gettext('Execution tic:  \n* One tic per state');
gettext('1-bit counter');
gettext('1-to-2 Demux');
gettext('Turn off  \nthe machine');
gettext('n=1');
gettext('n=0');
gettext('The next signal can only go inside the machine  \nif it is busy');
gettext('The machine is busy from the very  \nbegining in which the start_ok  \nsignal arrives');
gettext('Initial state cycle  \n(n = 0)');
gettext('When the next_ok signal is received  \nthe initial cycles is finished');
gettext('When the next_ok is received the counter is  \nincreased');
gettext('The machine is active: either in the first  \nstate cycle (n=0) or the next cycles (n=1)');
gettext('Wait one cycle for the  \ncounter to be updated');
gettext('The next_ok signal output either as the  \nexec signal (when n=1) or as the done signal  \nwhen (n = 0)');
gettext('Then count machine has three states:  \n\n* Idle: The machine is off, waiting to receive the start signal  \n* n = 0: Initial state cycle. It goes from receiveing the start signal until  \n  the first next signal arrives\n* n = 1: second state cycle. Fron the first next signal to the second');
gettext('## PUTC: Transmit 4bits as an hexadecimal digit (STDOUT bus)\n');
gettext('Write the digits (a-f) in  \nuppercase by default');
gettext('Condition: is the number  \nreceived between 10 and 15?  \n(a to f digit?)');
gettext('The digits a-f are changed to uppercase  \nby setting the 5th bit to 0 or 1');
gettext('dump');
gettext('icerok-probe');
gettext('16B memory sample machine. Captura the input data and store it in the memory');
gettext('16B memory. Bus interface');
gettext('16 Bytes Synchronous memory');
gettext('## Icerok-probe machine\n\nMachine for capturing data, storing it in the memory and transmit  \nto the computer by serial port');
gettext('Writing the data to the memory on  \nevery system clock cycle');
gettext('Transmiting the raw memory contents  \nto the computer, by serial port');
gettext('When the sampling is done  \ntransmit the information to  \nthe computer');
gettext('Memory were the data  \nis stored');
gettext('## Sample machine\n\nRead the input data, (one byte per clock cycle) and store it into the memory\n\n');
gettext('init');
gettext('16B memory init machine. Initilize the memory with consecutive numbers');
gettext('Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('## Init machine\n\nInitilize the memory starting from the address 0. The first value written   \nis the ini parameter. Then, it is incremented by 1 and  \nwritten in the following address:\n\n0: ini  \n1: ini+1  \n2: ini+2  \n3: init+3  \n...\n');
gettext('sample');
gettext('seq');
gettext('16B memory seq machine');
gettext('Sys-Delay-xN-32bits: The input tic is delayed N cycles');
gettext('Counter-M-x32: 32-bits M module counter with reset');
gettext('Inc1-32bit: Increment a 32-bits number by one');
gettext('AdderK-32bit: Adder of 32-bit operand and 32-bit constant');
gettext('Generic: 32-bits generic constant');
gettext('Adder-32bits: Adder of two operands of 32 bits');
gettext('Adder-8bits: Adder of two operands of 8 bits');
gettext('Bus8-Split-half: Split the 8-bits bus into two buses of the same size');
gettext('Adder-4bits: Adder of two operands of 4 bits');
gettext('Adder-1bit: Adder of two operands of 1 bit');
gettext('AdderC-1bit: Adder of two operands of 1 bit plus the carry in');
gettext('XOR gate: two bits input xor gate');
gettext('Constant bit 0');
gettext('Bus4-Split-all: Split the 4-bits bus into its wires');
gettext('Bus8-Join-half: Join the two same halves into an 8-bits Bus');
gettext('AdderC-4bits: Adder of two operands of 4 bits and Carry in');
gettext('AdderC-8bits: Adder of two operands of 8 bits and Carry in');
gettext('Bus16-Join-half: Join the two same halves into an 16-bits Bus');
gettext('Bus24-Join-8-16: Join the two buses into an 24-bits Bus');
gettext('Bus32-Split-8-24: Split the 28-bits bus into two buses of 8 and 24 wires');
gettext('Bus24-Split-16-8: Split the 24-bits bus into two buses of 16 and 8 wires');
gettext('Bus16-Split-half: Split the 16-bits bus into two buses of the same size');
gettext('Bus32-Join-8-24: Join the two buses into an 32-bits Bus');
gettext('Geu-32-Bits_v: 32-bit Unsigned Greather than or equal comparator. Verilog implementation');
gettext('32-Reg-rst: 32 bits Register with reset. Verilog implementation');
gettext('Unit-ms-32bits: ms to cycles converter');
gettext('Time to wait between two reads');
gettext('## Sequence machine:\n\nIt reads the whole memory, one byte at a time. Each read byte is  \nwritten to the data output along with its validation tic  \nIt starts from address 0. A done tic is emitted when finished  \nThe time is ms between two consecutive reads is a parameter set  \nby the user (300ms by default)\n\nThe typical application of this machine is to show the memory content  \non the LEDs');
gettext('Cycles to delay');
gettext('Delay finished!');
gettext('Machine state: ON/OFF');
gettext('RS Flip-Flop');
gettext('Circuit state:  \n* ON: working (1)\n* OFF: Not working (0)');
gettext('The counter has reached  \nthe number of cycles  \nto delay');
gettext('Maximum count  \nreached');
gettext('32-bits register');
gettext('If the max count is reached  \nand the cnt tic is received,  \nthe register is reset to 0');
gettext('External reset');
gettext('Input parameter: Milieconds  ');
gettext('Input parameter:  \nSystem Frequency');
gettext('sum');
gettext('16B memory sum. Calculates M0 = M1 + M2 + ..+ M15');
gettext('Sumador de un dos operandos de 8 bits (sin acarreo)');
gettext('Separador de bus de 3-bits');
gettext('Circuito combinacional de 5 entradas y 7 salidas');
gettext('Habilitación de bus de 7 bits');
gettext('Split a 7-bits-buts into two: 4-bits and 3-bits');
gettext('Máquina de contar, de 5 bits');
gettext('5-bits adder. One operand is a constant (no carry)');
gettext('two operand 5-bits comparator');
gettext('Valor genérico constante (menos 1), de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('05-Reg-rst: 5 bits Register with reset. Verilog implementation');
gettext('08-Reg-rst: 8 bits Register with reset. Verilog implementation');
gettext('Data from memory');
gettext('## Controller');
gettext('## Datapath');
gettext('## Sum machine \n\nMachine for calculate the operation M0 = M1 + M2 +...+ M7, where  \nMx is the data located at address x  \nrespectivelly\n\nThe Architecture of this machine is divided into:\n* Datapath  \n* Controller\n\nThe controller has been implemented using µinstructions');
gettext('Accumulator register');
gettext('µcmd: loading the register A');
gettext('µcmds generation');
gettext('Count machine: it reads sequentially the  \ntable with the µinstructions');
gettext('test-acc');
gettext('16B memory test acc. Calculates M0 = M0 + M1');
gettext('Circuito combinacional de 3 entradas y 4 salidas');
gettext('Habilitación de bus de 4 bits');
gettext('Agregador de buses de 3 y 1-bits a a bus de 4-bits');
gettext('3bits constant value: 0');
gettext('Generic: 3-bits generic constant (0-7)');
gettext('## Test-acc machine \n\nMachine for calculate the operation M0 = M0 + M1, where  \nM0 and M1 are the data located at addresses 0 and 1  \nrespectivelly\n\nThe Architecture of this machine is divided into:\n* Datapath  \n* Controller\n\nThe controller has been implemented using µinstructions');
gettext('µcmd: Add A to the current data  \nfrom memory');
gettext('Only address 00 and 01 are  \nused (1 bit)');
gettext('upload');
gettext('16B memory upload machine. Initilize the memory with data from the stdin');
gettext('stdin bus splitter into data and tic signals');
gettext('Máquina de contar, de 4 bits, con entrada de stop');
gettext('Count machine');
gettext('## upload machine\n\nWrite data into the memory. The data is taken from the serial port. Once the  \nmemory is full, the machine is done\n');
gettext('browse');
gettext('2B memory browse machine');
gettext('2-to-1 Multplexer (11-bit channels). Verilog implementation');
gettext('download');
gettext('2B memory download machine');
gettext('dump-tx');
gettext('2B Memory dump tx machine');
gettext('2B memory dump machine');
gettext(' Transmit one bit as a character. STDOUT-bus');
gettext('## Dump machine\n\nDump the contents of the memory to the serial port  \nThe data is shown in Hexadecimal ASCII\n\nExample:\n\n```\n| Addr | Data |\n|------|------|\n| 0    | 55   |\n| 1    | AA   |\n```\n...\n');
gettext('## PUTC-bit-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit input is sent as the character '0' or '1'  \nWhen not active, the stdout crossed the block (transparent mode)');
gettext('Bit to be transmited');
gettext('The bit to be transmitted should be  \nsyncronized with its transmit tic');
gettext('If the machine is ready and  \nthe next tic is received:  \nwe are done');
gettext('The machine is done');
gettext('Machine is on: send a character');
gettext('State of the machine  \n0: OFF  \n1: ON: Sending one character');
gettext('Character to transmit when  \nthe input bit is 1');
gettext('Character to transmit when  \nthe input bit is 0');
gettext('Select with character to transmit  \naccording to the input bit');
gettext('dump');
gettext('icerok-probe');
gettext('2 bytes buffer Logic analicer probe');
gettext('2B memory. Bus interface');
gettext('2 Bytes Synchronous memory');
gettext('2B memory sample machine. Captura the input data and store it in the memory');
gettext('init');
gettext('2B memory init machine. Initilize the memory with consecutive numbers');
gettext('Agregador de un bus de 7 bits y un cable a bus de 8-bits');
gettext('Valor genérico constante, de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('sample');
gettext('seq-inf');
gettext('2B memory seq-inf machine. Reproduce the sequence infinitely, until the stop signal is received');
gettext('Máquina de contar, de 1 bit, con entrada de Stop');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('TFF-rst-verilog: TFF with toggle input and reset: It toogles on every system cycle if the input is active. Verilog implementation');
gettext('¿Estamos en el  \nciclo 1?');
gettext('Si es el ciclo 1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Type of stop:  \n0: Internal (done)  \n1: External (abort)');
gettext('seq');
gettext('2B memory seq machine');
gettext('## Sequence machine:\n\nIt reads the whole memory, one byte at a time. Each read byte is  \nwritten to the data output along with its validation tic  \nIt starts from address 0. A done tic is emitted when finished  \nThe time in ms between two consecutive reads is a parameter set  \nby the user (300ms by default)\n\nThe typical application of this machine is to show the memory content  \non the LEDs');
gettext('test-acc');
gettext('2B memory test acc. Calculates M0 = M0 + M1');
gettext('upload-proto');
gettext('2B memory upload machine with stdout protocol. Initilize the memory with data from the stdin');
gettext('Transmit one constant character to the STDOUT bus');
gettext('## PUTC: Transmit one constant character ');
gettext('upload');
gettext('2B memory upload machine. Initilize the memory with data from the stdin');
gettext('12-download');
gettext('12-download-init');
gettext('download');
gettext('4B memory download machine');
gettext('2-to-1 Multplexer (12-bit channels). Verilog implementation');
gettext('dump-tx');
gettext('4B Memory dump tx machine');
gettext('4B memory dump machine');
gettext('Agregador de 2 buses de 6 y 2-bits a bus de 8-bits');
gettext('6bits constant value: 0');
gettext('Generic: 6-bits generic constant (0-63)');
gettext('## Dump machine\n\nDump the contents of the memory to the serial port  \nThe data is shown in Hexadecimal ASCII\n\nExample:\n\n```\n| Addr | Data |\n|------|------|\n| 00   | 55   |\n| 01   | AA   |\n| 02   | F0   |\n| 03   | 0F   |\n```\n...\n');
gettext('dump');
gettext('icerok-probe');
gettext('4 bytes buffer Logic analicer probe');
gettext('4B memory sample machine. Captura the input data and store it in the memory');
gettext('4B memory. Bus interface');
gettext('4 Bytes Synchronous memory');
gettext('2bits constant value: 0');
gettext('Generic: 2-bits generic constant (0,1,2,3)');
gettext('init');
gettext('4B memory init machine. Initilize the memory with consecutive numbers');
gettext('sample');
gettext('seq');
gettext('4B memory seq machine');
gettext('Mach-count-2-bits: 2-bits count machine');
gettext('OR-BUS2: OR gate with 2-bits bus input');
gettext('Bus2-Split-all: Split the 2-bits bus into two wires');
gettext('Counter-x02: 2-bits counter');
gettext('Inc1-2bit: Increment a 2-bits number by one');
gettext('AdderK-2bit: Adder of 2-bit operand and 2-bit constant');
gettext('Adder-2bits: Adder of two operands of 2 bits');
gettext('Bus2-Join-all: Joint two wires into a 2-bits Bus');
gettext('counter');
gettext('n>0');
gettext('The machine is active: either in the first  \nstate cycle (n=0) or the next cycles (n>0)');
gettext('Then count machine has three states:  \n\n* Idle: The machine is off, waiting to receive the start signal  \n* n = 0: Initial state cycle. It goes from receiveing the start signal until  \n  the first next signal arrives\n* n > 0: state cycles. From the first next signal to the fourth');
gettext('¿State different than 0?');
gettext('sum');
gettext('4B memory sum. Calculates M0 = M1 + M2 + M3');
gettext('Circuito combinacional de 3 entradas y 5 salidas');
gettext('Habilitación de bus de 5 bits');
gettext('Split a 5-bits bus into 2-bits and 3-bits buses');
gettext('## Sum machine \n\nMachine for calculate the operation M0 = M1 + M2 + M3, where  \nMx is the data located at address x  \nrespectivelly\n\nThe Architecture of this machine is divided into:\n* Datapath  \n* Controller\n\nThe controller has been implemented using µinstructions');
gettext('test-acc');
gettext('4B memory test acc. Calculates M0 = M0 + M1');
gettext('upload');
gettext('4B memory upload machine. Initilize the memory with data from the stdin');
gettext('download');
gettext('8B memory download machine');
gettext('2-to-1 Multplexer (13-bit channels). Verilog implementation');
gettext('dump-tx');
gettext('8B Memory dump tx machine');
gettext('8B memory dump machine');
gettext('Create an 8-bit bus from two buses of 5 and 3 bits');
gettext('5bits constant value: 0');
gettext('Generic: 5-bits generic constant (0-31)');
gettext('dump');
gettext('icerok-probe');
gettext('8 bytes buffer Logic analicer probe');
gettext('8B memory. Bus interface');
gettext('8 Bytes Synchronous memory');
gettext('8B memory sample machine. Captura the input data and store it in the memory');
gettext('init');
gettext('8B memory init machine. Initilize the memory with consecutive numbers');
gettext('sample');
gettext('seq');
gettext('8B memory seq machine');
gettext('sum');
gettext('8B memory sum. Calculates M0 = M1 + M2 + ..+ M7');
gettext('Circuito combinacional de 4 entradas y 6 salidas');
gettext('Habilitación de bus de 6 bits');
gettext('Separador de bus de 6-bits en dos de 3bits');
gettext('test-acc');
gettext('8B memory test acc. Calculates M0 = M0 + M1');
gettext('Bus joiner: 2-bits + 1bits into a 3-bits bus');
gettext('upload');
gettext('8B memory upload machine. Initilize the memory with data from the stdin');
gettext('06-bits');
gettext('Bus');
gettext('Join');
gettext('Join the fields into one 06-bits memory map bus');
gettext('Split');
gettext('Split a 06-bits memory map bus into its fields');
gettext('ROM-8KB');
gettext('8KB ROM memory (synchronous)');
gettext('01-bits');
gettext('12-bits');
gettext('16-bits');
gettext('17-bits');
gettext('Bytes');
gettext('KiB');
gettext('memory-dual-16B');
gettext('Memoria dual de 8 bytes');
gettext('Demultiplexor de 8 bit, de 1 a 2');
gettext('Memoria de 16 bytes');
gettext('## ENTRADAS');
gettext('### MEMORIA 1');
gettext('### MEMORIA 0');
gettext('**Selección de memoria**');
gettext('memory-dual-16KB');
gettext('Memoria de 16KB. Lectura síncrona');
gettext('memory-dual-256B');
gettext('Memoria dual de 256 bytes');
gettext('Memoria de 256 bytes');
gettext('memory-dual-2B');
gettext('Memoria dual de dos bytes');
gettext('Memoria de dos bytes');
gettext('2-to-1 Multplexer (1-bit channels). Verilog implementation');
gettext('memory-dual-4B');
gettext('Memoria dual de 4 bytes');
gettext('Memoria de 4 bytes');
gettext('2-to-1 Multplexer (2-bit channels). Verilog implementation');
gettext('memory-dual-8B');
gettext('Memoria de 8 bytes');
gettext('2-to-1 Multplexer (3-bit channels). Verilog implementation');
gettext('memory-str-0002B');
gettext('2-bytes memory, initilized with a string');
gettext('memory-str-0004B');
gettext('memory-str-0008B');
gettext('memory-str-0016B');
gettext('16-bytes memory, initilized with a string');
gettext('memory-str-0032B');
gettext('32-bytes memory, initilized with a string');
gettext('memory-str-0064B');
gettext('memory-str-0128B');
gettext('128-bytes memory, initilized with a string');
gettext('memory-str-0256B');
gettext('256-bytes memory, initilized with a string');
gettext('memory-512x1');
gettext('512 words of 1 bits memory (512 x 1)');
gettext('memory-512x12');
gettext('512x12 memory');
gettext('memory-16x16');
gettext('16x16 memory');
gettext('memory-512x17');
gettext('512 x 17 bits memory');
gettext('Bus');
gettext('memory-002B');
gettext('memory-004B');
gettext('memory-008B');
gettext('memory-016B');
gettext('memory-032B');
gettext('32 Bytes Synchronous memory');
gettext('memory-064B');
gettext('64 Bytes Synchronous memory');
gettext('memory-128B');
gettext('128 Bytes Synchronous memory');
gettext('memory-256B');
gettext('256 Bytes Synchronous memory');
gettext('memory-512B');
gettext('512 Bytes Synchronous memory');
gettext('memory-002B-bus');
gettext('memory-004B-bus');
gettext('memory-008B-bus');
gettext('memory-016B-bus');
gettext('memory-01KiB');
gettext('1KiB Bytes Synchronous memory');
gettext('memory-02KiB');
gettext('2KiB Bytes Synchronous memory');
gettext('memory-04KiB');
gettext('4KiB Bytes Synchronous memory');
gettext('memory-08KiB');
gettext('8KiB Bytes Synchronous memory');
gettext('memory-16KiB');
gettext('16KiB Bytes Synchronous memory');
gettext('memory-16KB-boot');
gettext('Memoria de 16KB, con Bootloader');
gettext('Máquina de contar, de 14 bits, con entrada de stop');
gettext('Sumador de un operando de 14 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 14 bits. Se compara si el operando es igual al parámetro');
gettext('Valor genérico constante (menos 1), de 14 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('14-Reg-rst: 14 bits Register with reset. Verilog implementation');
gettext('Máquina contadora de gestión del  \nBootloader. Al arrancar se pone a uno Boot_on  \ny por a1 sale 0, para acceder al primer byte  \nde la memoria a cargar');
gettext('## Entradas');
gettext('### Modo BOOTloader');
gettext('### Modo memoria normal');
gettext('## Salidas');
gettext('Dato a cargar en memoria, en Bootloader');
gettext('Tic de dato recibido, en bootloader');
gettext('Abortar el Bootloader. Se vuelve  \na modo normal');
gettext('Entrar en modo BOOTLOADER');
gettext('Estamos en modo BOOTLOADDER');
gettext('Dato leido de la memoria (Modo normal)');
gettext('Tic de Modo booloader finalizado  \n(Carga completada)');
gettext('Seleccionar canal 1 en  \nmodo Bootloader. De lo  \ncontrario seleccionar modo normal');
gettext('Los datos recibidos sólo se  \ndejan pasar si estamos en  \nel modo bootloader');
gettext('Escribir dato recibido en  \nla posicion actual de  \nla memoria');
gettext('Pasar a la siguiente  \ndirección');
gettext('Cuando se llega al final  \nboot_on se pone a 0 y  \nse envia un tic por done');
gettext('CT9-Examples');
gettext('TESTs');
gettext('01-Regs');
gettext('02-Banks');
gettext('03-Sync-Memory');
gettext('04-Example-circuits');
gettext('05-Memory-map-io');
gettext('01-Reg-1bit-01');
gettext('Pulsador de cambio. Cada vez que se aprieta cambia de estado');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('1-Bit register (Implemented with icestudio blocks)');
gettext('Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato');
gettext('## Example 1: 1-bit register test\n\nWith the pushbutton 1 the value of the bit to capture is  \nset. It it shown in LED7. When the pushbutton 2 is pressed,  \nthis bit is stored in the register and shown on LED0\n');
gettext('Shown the data capture  \non the LED0');
gettext('Select the bit to capture  \n0/1');
gettext('The bit to capture is shown  \non LED7');
gettext('This button is for  \ncapturing the data');
gettext('1 Bit register');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=QwBvRpHyT1g)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/QwBvRpHyT1g/0.jpg)](https://www.youtube.com/watch?v=QwBvRpHyT1g)');
gettext('Valor inicial del pulsador\n');
gettext('**Pulsador-tic**');
gettext('Mux 2-1');
gettext('D Flip-flip\n(System)');
gettext('02-Reg-1bit-panel');
gettext('Virtual Switch. Receiving unit');
gettext('Virtual Input Bus: Virtual inputs components receiver');
gettext('Virtual input bus Joiner');
gettext('Receptor serie asíncrono. Velocidad por defecto: 115200 baudios');
gettext('Virtual switch (1-bit). Bus block');
gettext('char syntax block');
gettext('Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('bit syntax block');
gettext('Extractor de 1 bit de un bus de 8 bits');
gettext('Virtual input bus Splitter');
gettext('Syntax End Of Line. Last block when detecting a command');
gettext('Virtual-pushbutton. Bus block');
gettext('One Virtual LED with bus expansion');
gettext('Two Virtual LEDs. Transmission block');
gettext('Puerta XOR');
gettext('Virtual output bus Splitter');
gettext('Virtual output bus Joiner');
gettext('Multiplexor de 2 a 1 de 18 bits');
gettext('Separador de bus de 2-bits en dos cables');
gettext('Virtual Output Bus');
gettext('Print a Bit variable + LF');
gettext('Print a bit plus a new line');
gettext('Código ASCII del carácter LF');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos');
gettext('10 bits, 2-1 Multiplexor');
gettext('Registro de 8 bits');
gettext('Serial transmiter for the stdout bus');
gettext('Transmisor serie');
gettext('## Example 2: Testing a 1-bit register from the web panel\n\nThe \"q\" switch is used for selecting the data bit (0/1) and the pushbutton  \n\"Q\" for capturing this data. The state of the switch \"q\" is shown on the virtual  \nLED \"a\" and the register output on the \"h\" virtual LED');
gettext('Show the register output  \non LED0');
gettext('The bit to capture is shown  \non physical LED7');
gettext('### Output in two LEDs');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=XiyCVTiudLE)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/XiyCVTiudLE/0.jpg)](https://www.youtube.com/watch?v=XiyCVTiudLE)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Reg-1bit-06.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Reg-1bit-06.png)');
gettext('# Virtual Switch-first\n\nThis component should be placed in the  \nfirst place. It creates the Virtual  \ninput BUS for connecting other blocks');
gettext('One cycle after the EOL character  \nis received, the bus is reset');
gettext('## Virtual Input Bus\n\nIt receives the commands generated by the virtual components  \nand it sents them thought the VIB bus');
gettext('**Serial receiver**');
gettext('an End of line character  \ndetected: CR or LF');
gettext('This tick indicates that  \nan eol character has  \nbeen received');
gettext('**VIB BUS**');
gettext('End of command received: All the  \nreceivers connnected to the bus should  \ngo to its initial state for detecting  \nthe next command');
gettext('Signal: End of Line received  \nIt is detected here for optimization  \npurposes. This way the receivers should  \nnot implement the EOL detection');
gettext('**Virtual Input Bus**');
gettext('The bit received from the virtual  \ncomponent is stored in this flip-flop');
gettext('When the virtual switch  \nis changed, a tic es emited');
gettext('The swith has changed  \nto the ON state');
gettext('The swicth has changed  \nto the OFF state');
gettext('# Virtual Switch\n\nProcess the commands from the virtual components  \nGet the bit if the messages is for this switch');
gettext('## Syntax Char  \n\nSyntax block for receiving a specific character  \n\nWhen the character recived is what the block is expecting,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is different from what it was expecting,  \nthen block blocks. it disconnect itself from the input until it is reset');
gettext('**Reset the block**');
gettext('**Input character**');
gettext('**Active state**  \n0: Block is not active  \n1: In Active mode');
gettext('Depending on the mode, the tic  \nreceived is outputed (transparent mode)\nor sent inside the block for further processing\n');
gettext('Transparent mode');
gettext('Ignored');
gettext('If the block is blocked, the tic  \nis ignored. Else the tic is sent  \nto the next stage for further processing');
gettext('**Expected character**');
gettext('State of the received character  \n0: Not the one was expected   \n1: The one that was expected  ');
gettext('Expected character  \nreceived: Change to   \nactive mode');
gettext('Other character received:  \nBlock the component');
gettext('**Block state**  \n0: Not blocked\n1: Blocked');
gettext('## Syntax Bit  \n\nSyntax block for receiving a bit ('0'/'1')\n\nWhen the character recived is a bit,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is not a bit,  \nthe block blocks. it disconnects itself from the input until it is reset');
gettext('State of the received character  \n0: No bit symbol received  \n1: Bit received ');
gettext('Bit received:  \nChange to   \nactive mode');
gettext('**Block state**  \n0: Not blocked  \n1: Blocked');
gettext('Capture the bit  \nreceived');
gettext('Last block:  \nIt is blocked with any  \ncharactere received');
gettext('The received char was  \nan END of LINE: OK!');
gettext('## Syntax EOL\n\nThis block should be the last one. It checks if the last correct  \ncharactere received is an end-of-line\n\nAs it is the last block, it always get blocked when a characterer  \narrives. If it is an EOL, it is send through the ok_tic\n');
gettext('The block is exactly the same than the  \nswitch-bus, but with another icon');
gettext('**2 LEDs Virtuales**');
gettext('**LED Virtual**');
gettext('Is the current bit  \ndifferent than the  \nprevious?');
gettext('Yes');
gettext('Store the bit that is being  \ntransmitter');
gettext('# Virtual LED\n\nTurn on a virtual LED. The information is sent  \nthough the VOB bus');
gettext('When the block is actived, it  \ntakes the bus and send its  \ninformation. Otherwise it is transparent');
gettext('Get the signal from the VOB that  \nneeded for this component');
gettext('Another component  \nis using the bus');
gettext('Initialization state:  \n0 : The component has not sent its  \n    initial state yet  \n1 : The initialization is done');
gettext('Send the initial state');
gettext('Actived sinal: The LED is sending a bit  \n0 : The LED is not sending anything  \n1 : Send a bit');
gettext('Bit to send: either the one on the  \ninput or a 0 if it is the first time');
gettext('This is for sending bits ONLY if the  \ninput is different than the bit  \npreviously sent');
gettext('It only sends if the transmiter is  \nnot busy');
gettext('There is new bit to  \nbe sent');
gettext('If other is using the bus:  \nthe request cannot be sent');
gettext('The bit can be sent!');
gettext('Whenever a bit is transmited,  \nthe initialization is stoped!');
gettext('# Virtual LED-tx\n\nComponent for turning on a Virtual LED  \nIt should be placed in the last output position  ');
gettext('Send the string \"a0\\n\"  \nor \"a1\\n\"');
gettext('## Virtual Output Bus\n\nIt receives the information from the Output Virtual devices  \nand sends the messages to the PC though the serial port\n');
gettext('Bus: information from the other  \nelements connected to the VOB  ');
gettext('Get the diffent fields on the bus');
gettext('Boolean variable name');
gettext('Boolean variable value');
gettext('Request bus Tic  \nSend the message!');
gettext('Serial transmitter');
gettext('The busy signal is sent to the bus  \nThe rest of the signals are  \nset to 0');
gettext('## PRINTLN-bit-var\n\nPrint a Bit Variable. The output format is:  \n< Varname > < Bit > < LN >  \nWehre < Varname >  is a 1-char variable identifier\n\nExample: \"a1\\n\"');
gettext('Print the Variable  \nidentfifies');
gettext('Print the variable  \nbit value + \\n');
gettext('Before print, both variable name  \nand variable value are store into  \na register');
gettext('Store the variable  \nname');
gettext('Store the bit  \nvalue');
gettext('This print machine  \ngets busy as soon as  \nthe print gets high');
gettext('## PrintLn-bit: Print one bit plus a new line character  \n');
gettext('**Block 1**  \nPrint the bit (0,1)');
gettext('The machine is busy either  \nthe block 1 is busy or  \nthe block 2 is busy');
gettext('**Block 2**  \nPrint new line char');
gettext('## Detector doble: flancos de subida y bajada\n\nSe detectan tanto los flancos de subida como de bajada y se emite los  \ntics por sus salidas correspondientes');
gettext('Señal de  \nentrada');
gettext('Reloj del  \nsistema');
gettext('03-Reg-2bits-01');
gettext('Contador módulo M, ascendente, de 2 bits, con reset ');
gettext('2-bits register (implemented with blocks)');
gettext('## Example 3: Testing the 2-bits register\n\nBy means of the pushbutton sw1 a 2-bit number is selected  \nand it is shown in the LEDs 7 and 6. When the button 2 is  \npressed the data is captured and stored into the 2-bit register \nThe register output is shown in the LEDs 1 and 0');
gettext('Show the output data');
gettext('Counter: input data  \nto the register');
gettext('When this button is pressed  \nthe input data is captured  \ninto the register');
gettext('2-bits register');
gettext('Increment the  \ninput data');
gettext('## Youtube Video (TODO)\n\n[Link](https://www.youtube.com/watch?v=FGu0DZ8cpkY)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/FGu0DZ8cpkY/0.jpg)](https://www.youtube.com/watch?v=FGu0DZ8cpkY)');
gettext('Show the input data');
gettext('**Parámetro**: Módulo del contador');
gettext('04-Reg-2bits-panel');
gettext('Two Virtual Switches. Receiving unit');
gettext('Two Virtual LEDs. Bus element');
gettext('## Example 4: Testing the 2-bit register with the web panel\n\nThe virtual Pushbutton \"Q\" is used for capturing the 2-bits input data. With the  \n\"A\" and \"B\" switches the input value is set and shown on virtual LEDs \"G\" and \"H\"  \nThe register output is shown on the \"G\" and \"H\" virtual LEDs');
gettext('Show the output on both  \nthe real LEDs 0, 1 and...\n');
gettext('... the Virtual LEDs');
gettext('The 2-bits input data is shown on\nboth the real and virtual leds\n');
gettext('Virtual LEDs');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Reg-2bits-07.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Reg-2bits-07.png)');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=vd2wBs9Z__0)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/vd2wBs9Z__0/0.jpg)](https://www.youtube.com/watch?v=vd2wBs9Z__0)');
gettext('# Switchx2-RX\n\nReceives the state of two virtual Inputs');
gettext('05-Bank-2x1-01');
gettext('Detect different clicks on the button: normal click, doble click or long click');
gettext('Pulsador con tic de cambio, pulsación y liberación de tecla');
gettext('Sincronizar las entradas de datos con el reloj del sistema');
gettext('Remove the rebound on a mechanical switch');
gettext('Detect changed on the input signal ');
gettext('Test if a tic is received within time');
gettext('Timer in ms, with start and stop');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Contador módulo M, ascendente, de 12 bits, con reset ');
gettext('Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado');
gettext('Input data  \n(0/1)');
gettext('Bank register  \naddress (0/1)');
gettext('2x1 register bank');
gettext('The bank output is shown  \non LED0');
gettext('The input data is  \nshown on LED5');
gettext('Show the address  \non LED7');
gettext('## Example 5: Testing the two 1-bit register bank (2x1 Bank)\n\nTesting the 2x1 register Bank. With the SW1 pushbutton the input data is set (0/1).  \nWith the SW2 pushbutton the address (0/1) is selected. By means of a long press  \non the SW1 button, the input data is written in the current address. The content of the  \nselected register is shown on LED0\n');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=ES5GzFeYlN8)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ES5GzFeYlN8/0.jpg)](https://www.youtube.com/watch?v=ES5GzFeYlN8)');
gettext('## Button-click-3  \n\nDetect three different types of clicks in the Button:\n\n* Normal click  \n* Doble click  \n* Long click');
gettext('When the button is pressed  \nthe timer 1 is started');
gettext('If the button is pressed again  \nwithin the time, it is  \na doble click');
gettext('Timeout: It was  \nnot a doble click');
gettext('Check the current  \nbutton state: pressed  \nor not pressed');
gettext('Button state');
gettext('Button state:  \n1: Pressed  \n2: Not pressed');
gettext('Button is released:  \nwe have a click  \nIt is NOT a long click');
gettext('Button is still  \npressed: we do not know yet  \nif it is a click or long click');
gettext('Timeout for detecting a \ndoble click  \nAfter this time is not considered a  \ndoble click but two clicks in a row');
gettext('Wait for the release  \ntic');
gettext('Release tic has arrived  \nwithin time: it was a  \nnormal click  ');
gettext('In both cases it is  \nconsider a normal click');
gettext('The button has not been  \nreleased after the specified  \ntime: it is a long click');
gettext('**Outputs**');
gettext('## Change detector  \n\nIt emits the followings tics:\n\n* When there is a rising edge on the input signal\n* When there is a falling edge\n* When there is either a rising or falling edge');
gettext('## Timer-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Start the machine');
gettext('Tic to detect within time');
gettext('Main timer');
gettext('Start the timer');
gettext('If a tic is received when  \nthe timer is still on,  \nlet it pass...');
gettext('The tic is delayed one unit  \nto prevent reache the timer  \nin the same cycle than start  \n(it can happens if the same tic is  \nconnect both to start and tic inputs)  ');
gettext('Stop the timer:  the tic  \nhas arrived in time');
gettext('The tic arrived in time  \nTic detected!');
gettext('No tic detected  \nwithin time');
gettext('The machine is on');
gettext('tic: No input tic detected');
gettext('tic: input tic detected!');
gettext('Biestable de estado  \nde la máquina');
gettext('Mientras la máquina  \nesté apagada el  \ncontador está a 0');
gettext('Contador de tiempo  \nen unidades de  \nmilisegundos');
gettext('El tiempo ha expirado:  \napagar la máquina');
gettext('Unidades de tiempo:  \n1000 microsec = 1ms');
gettext('Al arrancar la máquina,  \neste corazón emite un  \ntic cada 1 ms');
gettext('**Parámetro**:  \nms de espera');
gettext('Sacar el tic de apagado de  \nla máquina por abort o done  \nsegún cómo haya sido');
gettext('Si es por stop: El timer ha abortado  \nSi no, es una terminación normal (timeout)');
gettext('06-Bank-2x1-panel');
gettext('two 1-bit register bank');
gettext('The bank output is also  \nshown on the real LED 0');
gettext('## Example 6: Testing the two 1-bit register bank (2x1 bank) from the web panel  \n\nWith the \"h\" virtual switch the address is selected (reg 0 or 1). With the switch \"H\"   \nthe input data is set (0/1). The virtual push button \"Q\" writes the input data into  \nthe selected register (0/1). The output of the bank is shown on both the virtual led \"H\"  \nand the real LED 0. The current register is shown on virtual LED \"h\" and real LED 7');
gettext('### Output on two virtual LEDs');
gettext('Current address is shown  \non LED 7');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=52wk3DeEDJI)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/52wk3DeEDJI/0.jpg)](https://www.youtube.com/watch?v=52wk3DeEDJI)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-2x1-07.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-2x1-07.png)');
gettext('07-Bank-2x1-paralell-panel');
gettext('2x1 bit register bank');
gettext('The bank output is also shown\non LED0');
gettext('## Example 6: Testing the two 1-bit register bank with paralell output  \n\nWith the virtual switch \"h\" the address is selected (0/1). With the switch \"H\" the input \ndata is set and with the switch \"Q\" the data is written\nThe bank output is shown on both the virtual LED \"H\" and the real LED 0\nThe current address is shown on virtual LED \"h\" and Real LED 7\nIn addition, the paralell output is shown both on Virtual leds \"A\" and \"B\", and  \nreal LEDs: 7 and 0');
gettext('### Output on two LEDs');
gettext('The current addres is also\nshown on LED7');
gettext('Paralell output  \non virtual LEDs');
gettext('Show the paralell output  \non  LED3 and LED4 ');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=FmFjxVQRNxo)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/FmFjxVQRNxo/0.jpg)](https://www.youtube.com/watch?v=FmFjxVQRNxo)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-2x1-11.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-2x1-11.png)');
gettext('08-Bank-8x1-01');
gettext('Contador módulo M, ascendente, de 3 bits, con reset ');
gettext('## Example 8: Testing the 8 x 1 bit register bank\n\nThe pushbutton 2 set the current address. This address is shown on the LEDs 7,6 and 5.  \nThe bank output is shown on LED0\nWhen the pushbutton 1 is pressed, the current register is toggled \n\n');
gettext('Address (0-7)');
gettext('8x1 Bank');
gettext('Show the output  \nof the current  \nselected reg on the LED');
gettext('Show the current address  \non the LEDs');
gettext('3 bits counter');
gettext('Toggle the output bit');
gettext('Write the input data in the bank');
gettext('09-Bank-8x1-panel');
gettext('Three Virtual Switches. Receiving unit');
gettext('Three Virtual LEDs. Bus unit');
gettext('8x1 bit register bank');
gettext('The bank output is also  \nshown on a real LED');
gettext('## Example 9: Testing the 8 x 1 bit register bank with a web panel\n\nThe virtual switches \"f\", \"g\" and \"h\" (3 bits) are used to enter the address (0-7).  \nThe switch \"H\" is for the input data and the \"Q\" pushbutton for writing the input  \ndata into the bank\n\nThe bank output is shown on virtual LED \"H\" and real LED0. The current address  \nis shown on virtual LEDs \"f\", \"g\" and \"h\" and on real LED7, 6 and 5\n ');
gettext('Show the current address  \non real LEDs');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=s_Jepelyjec)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/s_Jepelyjec/0.jpg)](https://www.youtube.com/watch?v=s_Jepelyjec)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x1-06.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x1-06.png)');
gettext('# Switchx3-RX\n\nReceives the state of 3 virtual Inputs');
gettext('**3 Virtual LEDs**');
gettext('10-Bank-8x1-paralell-panel');
gettext('Two Virtual Pushbuttons');
gettext('Two Virtual Switches');
gettext('Eight virtual LEDs. Transmision block');
gettext('Four virtual LEDs. Transmision block');
gettext('Four virtual LEDs. Bus block');
gettext('8x1 bits register bank');
gettext('## Example 10: Testing the 8x1 register bank with paralell outputs with a web panel    \n\nThe button 'R' increments the current address. This address is shown on the  \nvirtual LEDs \"f\", \"g\" and \"h\". With the button 'Q' the register is toggled.  \nThe output of all the registers are shown both on virtual LEDs \"A\"-\"H\" and  \nreal LEDs 0-7');
gettext('Paralell output    \n8 1-bit registers');
gettext('### The output of the registers is shown on virtual LEDs ');
gettext('### Current address');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x1-09.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x1-09.png)');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=PZmN7Iwg6dA)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/PZmN7Iwg6dA/0.jpg)](https://www.youtube.com/watch?v=PZmN7Iwg6dA)');
gettext('# Pushbuttonsx2\n\nReceives the state of two virtual Inputs  \nIt is exactly the same than the switchx2 block,  \nbut with a different icon');
gettext('# Switchx2\n\nReceives the state of two virtual Inputs');
gettext('11-Bank-8x8-leds');
gettext('Contador módulo M, ascendente, de 3 bits');
gettext('8-bits register (implemented with blocks)');
gettext('4-bits register (implemented with blocks)');
gettext('Separador de bus de 4-bits en buses de 2 bits');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('8x8 register bank');
gettext('## Example 11: Testing the 8x1 register bank with LEDs and pushbuttons    \n\nThe pushbutton 2 increments the address. The bank output is shown on the LEDs\nThe pushbutton 1 increments the current register:\n* The increment is 1 with a short press\n* The inncrement is 64 with a long press\n');
gettext('Short press');
gettext('Long press');
gettext('3-bits counter');
gettext('Current address');
gettext('Both press emits a write pulse  \nfor writing in the bank: short  \nand long');
gettext('Increment the current  \nregister');
gettext('bank output');
gettext('The current 8-bit reg is shown  \non the LEDs');
gettext('2 to 1 coder');
gettext('It is 0 when any input  \nis active\n');
gettext('12-Bank-8x8-panel');
gettext('Four Virtual buttons');
gettext('Four Virtual Switches. Receiving unit');
gettext('Two Virtual Switches. Bus unit');
gettext('Contador ascendente/descendente de 3 bits (sin limites)');
gettext('## Example 12: Testing the 8x8 register bank with a web panel\n\nThe virtual buttons 'S' and 'T' increment and decrement the current address. This address  \nis shown on virtual LEDs \"f\", \"g\" and \"h\". With the buttons \"Q\" and \"R\" the current register   \nis incremented by a value of 1 or 64 respectivelly\n\nThe register value is shown both on Virtual LEDS \"A\"-\"H\" and real LEDs 7-0\n');
gettext('### Show the registers on the Virtual LEDs');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=Rkkcw0OxsE8)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/Rkkcw0OxsE8/0.jpg)](https://www.youtube.com/watch?v=Rkkcw0OxsE8)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x8-05.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Bank-8x8-05.png)');
gettext('Write the  \nnew value');
gettext('# Pushbuttonx4\n\nReceives the state of four virtual Inputs');
gettext('# Switchx4-RX\n\nReceives the state of four virtual Inputs');
gettext('# Switchx2-Bus\n\nReceives the state of two virtual Inputs');
gettext('13-Bank-8x8-read-cycle');
gettext('3-bits system counter with reset');
gettext('16B memory icerok probe');
gettext('Serial transmiter for the stdout bus (1 char buffer)');
gettext('Serial transmitter with a buffer for 1 byte');
gettext('1-byte buffer');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('8-bits register (in verilog)');
gettext('Multiplexor de 2 a 1 de 14 bits');
gettext('Registro de 4 bits con entrada de reset');
gettext('Join 3 buses of 3,1 and 4 bits into one of 8-bits');
gettext('Pushbutton for reseting the counter and  \nstart the data capturing');
gettext('3-bits counter, with  \nreset');
gettext('Write signal always 0:    \nRead cycles');
gettext('8x1 Byte register bank\n');
gettext('Only the 4 least significant bits  \nare captured\n');
gettext('Probe adaptor');
gettext('Icerok Probe');
gettext('## Example 13: Measuring read cycles of an 8x8 register bank\n\nWhen the pushbutton SW1 is pressed, the counter is reset and the signals  \naddr, write and data are sampled. A total of 16 read cycles are done. The data are  \nreceived by the Icerok Plug-ing and shown in the Pulseview application\n');
gettext('Empty Buffer  \n(There is no byte  \nwaiting)');
gettext('Byte stored in the  \nbuffer, waiting to be  \ntransmitted when the  \ntransmitter is ready');
gettext('Buffer state:  \n0: empty  \n1: full');
gettext('Transmitter ready');
gettext('If the transmittter is ready  \nand there is a character  \nin the buffer: Transmit!');
gettext('Serial transmitter state');
gettext('14-Bank-4x8-write-cycle');
gettext('Valor constante 0, de 6 bits');
gettext('Valor genérico constante, de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Split an 8bit-bus into two of 6 and 2 bits');
gettext('Registro de 3 bits con entrada de reset');
gettext('Join 5 buses of 1,2,1,2 and 2 bits into one of 8-bits');
gettext('4 x 1B register bank\n');
gettext('Only the 2 least significant  \nbits are shown in the capture\n');
gettext('Icerok probe');
gettext('Pushbutton for staring  \nthe data capture');
gettext('3-bits count machine\n  ');
gettext('The most significant bit is used  \nto determine the type of cycle:  \nread or write');
gettext('After the machine is started,  \nthe firt 4 cyles are write cycles,  \nand the next 4 are read cycles\n');
gettext('The data written in the  \naddress x is x+1\n');
gettext('## Example 14: Measuring write cycles of an 8x8 register bank\n\nWhen the pushbutton SW1 is pressed, the capture and the 3-bits count machine are started\nIn total, 8 memory cycles are generated. The first 4 are write cycles and the next 4 are  \nread cycles. The most significant bit of the counter is used as the write signal.\nFive signals are captured: trig, addr, write, din and dout\nThe data are received by the Icerok Plug-in and shown in the Pulseview application\n');
gettext('15-Bank-4x8-read-write-cycle');
gettext('Separador de bus de 3-bits, en dos de2 y 1 bits');
gettext('Con este pulsador se  \ninicia la captura de datos');
gettext('After the machine is started,  \neven cycles (0,2) are for reading and  \nodd cyles (1,3) for writing');
gettext('The data written at address  \nx is x+1');
gettext('## Example 15: Measuring combined write and read cycles of an 4x1B register bank\n\nWhen the pushbutton 1 is pressed, the capture and the 3-bits count machine are started.  \nIn total, 8 memory cycles are generated. The even one are read cycles and the odd one are  \nwrite cycles. The least significant bit of the counter determines the type of cycle\nFive signals are captured: trig, addr, write, din and dout. The data are received by the  \nicerok Plug-in and shown in the Pulseview application');
gettext('The **least** significant bit is used  \nto determine the type of cycle:  \nread or write');
gettext('16-Mem16B-leds');
gettext('4bits Up/Down counter (block implementation)');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('16B Memory');
gettext('## Example 16: Testing a 16B memory with LEDs and pushbuttons    \n\nWith the SW1 and SW2 pushbuttons you can navigate through the memory,  \nseeing the contents of current address on the LEDs:\n\n* SW1: Move to the next position (addr+1)\n* SW2: Move to the previous position (addr-1)\n\nBy default, the data written into the memory is equal to its address\n\nBy means of long press of the SW1 and SW2 pushbuttons, the current value  \ncan be changed\n\n* Long SW1: Increment 1 unit\n* Long SW2: Increment 64 units');
gettext('short press: previous address  \n(addr-1)');
gettext('Long press: Increment the current  \ndata by 1  ');
gettext('4-bits counter');
gettext('With long pressed, a write  \npulse is emitted for updating  \nthe data at the current position\n');
gettext('Increment the current  \ndata');
gettext('Output data');
gettext('The memory output is shown  \non the LEDs');
gettext('It is set to 0 when  \nany of the inputs is  \nactive');
gettext('Short press: next address  \n(addr + 1)');
gettext('Long press: Increment the current  \ndata by 64');
gettext('17-Mem16B-panel');
gettext('## Example 17: Testing a 16B memory with the web panel\n\nWith the virtual pushbuttons 'T' and 'S' the current address is incremented/decremented. This address is  \nshown on the virtual LEDs \"e\", \"f\", \"g\" and \"h\". With the buttons \"Q\" and \"R\" the current data is  \nincremented by 1 or 64 respectivelly. The memory output is shown on both virtual LEDs \"A\"-\"H\" and  \nreal LEDs (LED7-LED0)');
gettext('### Memory output on the virtual LEDs');
gettext('### Current Address');
gettext('A write pulse is emmited whenever  \nthe increment buttons are pressed\n');
gettext('It is 0 when some of  \nthe inputs are active\n');
gettext('4 bits counter');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=0iCEO0lWBd8)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/0iCEO0lWBd8/0.jpg)](https://www.youtube.com/watch?v=0iCEO0lWBd8)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Smem-14.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/Smem-14.png)');
gettext('18-Smem-16B-read-cycle');
gettext('4-bits system counter with reset');
gettext('Separador de bus de 4-bits en buses de 1 bits y 3 bits');
gettext('The pushbutton the counter is reset  \nand the capture started  \n');
gettext('4-bits counter, with  \nreset');
gettext('Write signal always 0:  \nOly read cycles');
gettext('16B Synchronous  \nmemory');
gettext('Only the 4 least significant  \nbits are shown on the capture\n');
gettext('Adaptor');
gettext('## Example 18: Measuring the read cycles on a 16B synchronous memory\n\nWhen the pushbutton sw1 is pressed the counter is reset and the capture of the signals  \naddr, write and data is started. In total 16 read cycles are done. The data is received  \nby the icerok plugin and it is displayed on the Pulseview application\n');
gettext('19-Smem-16B-write-cycle');
gettext('Valor constante 0 para bus de 2 bits');
gettext('Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('16B sync memory');
gettext('Only the 2 least significant  \nbits are captured');
gettext('Pushbutton for starting  \nthe data capture');
gettext('3-bits count machine');
gettext('The most significant bit is used for  \ndetermining the type of cycle:  \nwrite or read cycle');
gettext('After the machine is started,  \nthe 4 first cycles are write cycles  \nand the next 4 are read cycles');
gettext('The data written in the x  \naddress is x + 1');
gettext('## Example 19: Measuring the write cycle on a 16B Synchronous memory\n\nWhen the SW1 pushbutton is pressed, the 3 bits count machina and the capture are started  \nIn total 8 cycles are generated: The first 4 are write cycles and the next 4 are read cycles  \nThe most significant bit of the counter is used as the write signal  \nThe signals trig, addr, write, din and dout are captured. The data is received by the  \nIcerok plugin and displayed on the Pulseview app');
gettext('20-Smem-16B-read-write-cycles');
gettext('adaptor');
gettext('After the machine is started,  \nthe even cycles (0,2) are for   \nwriting and the odd cycles (1,3)  \nfor reading\n');
gettext('## Example 20: Measuring combined write and read cyles on a 16B sync memory\n\nWhen the SW1 pushbutton is pressed, the 3 bits count machina and the capture are started  \nIn total 8 cycles are generated: The first 4 are write cycles and the next 4 are read cycles  \nThe **least** significant bit of the counter is used as the write signal  \nThe signals trig, addr, write, din and dout are captured. The data is received by the  \nIcerok plugin and displayed on the Pulseview app\n');
gettext('The **least** significant bit is used for  \ndetermining the type of cycle:  \nwrite or read cycle');
gettext('21-Mem1KiB-panel');
gettext('8 Virtual Switches. Bus unit');
gettext('Four Virtual Switches. Bus unit');
gettext('Agregador de buses de 2 y 8 bits a uno de 10bits');
gettext('## Example 21: Testing the 1KiB sync memory from a web panel\n\nThe virtual switches \"s\" - \"t\" and \"a\"-\"h\" (10 bits) are used to enter the memory address  \nThe virtual swithces \"A\"-\"H\" are used to enter the input data, the one we can to write into memory  \nWith the virtual pushbutton \"Q\" the input data is written into the memory at the current address');
gettext('### Memory output');
gettext('### Input Data');
gettext('The memory output is also  \ndisplayed on the real LEDs');
gettext('Write the data');
gettext('For testing purposes the position 0x100 is initialized  \nwith the value 0xAA and the position 0x300 with 0x55.  \nAll the rest positions contain 0');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=DqZmmisI9n8)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/DqZmmisI9n8/0.jpg)](https://www.youtube.com/watch?v=DqZmmisI9n8)');
gettext('# Switchx8-Bus\n\nReceives the state of four virtual Inputs');
gettext('# Switchx4-Bus\n\nReceives the state of four virtual Inputs');
gettext('22-Mem1KiB-panel-file');
gettext('## Example 22: 1KiB Memory initialization from a file\n\nSame example than 21, but the memory is initialized from the **Ex22.list** file\n\nThe virtual switches \"s\" - \"t\" and \"a\"-\"h\" (10 bits) are used to enter the memory address  \nThe virtual swithces \"A\"-\"H\" are used to enter the input data, the one we can to write into memory  \nWith the virtual pushbutton \"Q\" the input data is written into the memory at the current address');
gettext('Memory initialized from  \nthe \"EX22.list\" file');
gettext('This file should be in the same  \nfolder than the icestudio circuit\n(.ice file)');
gettext('23-Prog-sequence-LEDs');
gettext('Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización');
gettext('Separador de bus de 6-bits en 1 bit y bus de 5 bits');
gettext('Contador del sistema, ascendente, de 6 bits, con enable ');
gettext('## Example 23: Programable sequence on LEDs\n\nA sequence of 16 states is displayed on the LEDs, using a 16B synchronous memory  \nWhen the SW1 button is pressed, the circuit enter into the upload mode. All the 16 bytes  \nreceived from the Serial port are stored into the memory. When the upload has finished, it changes  \nautomatically to the sequence mode, where the new sequence is displayed on the LEDs');
gettext('The memory output is  \ndisplayed on the LEDS\n');
gettext('Initial contents of the memory:  \nSequence to play on the LEDs');
gettext('16B Synchronous memory');
gettext('Initial start');
gettext('Machine 0: playing the  \nsequence  ');
gettext('Duration in ms of the  \ndata on the LEDs');
gettext('When the machine is done,  \nit start over again  \n(hardware infinite loop)');
gettext('## Machine 0: Sequence playing  ');
gettext('## Machine 1: Uploading data from the PC\n\nWhen the SW1 button is pressed this machine is started. Everytime  \na byte is received from the PC it is stored in the current  \naddress and the address is incremented by 1. After 16 bytes  \nreceived, the machine is done');
gettext('Count machine. From  \n0 to 15  ');
gettext('One cycle after writing the data  \ninto memory the address is incremented  \nby 1  \n');
gettext('Receiving data from the PC');
gettext('The data is only written into memory  \nif the upload machine is active  \n(that is, the user has pressed the  \nSW1 pushbutton)\nAnydata received previously is ignored');
gettext('Data writting  \nOnly in upload mode');
gettext('In upload mode, the address is taken  \nfrom machine 1. Otherwise it is taken  \nfrom the machine 0');
gettext('Signal the upload  \nmode');
gettext('**Arranque del**  \n**temporizador**');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('24-Mem-dump-increment');
gettext('Contador módulo M, ascendente, de 4 bits, con reset ');
gettext('## Example 24: Memory dump and increment\n\nWhen the pushbutton SW1 is pressed the 16B of the memory are dumped  \nthrough the serial port. The data can be seen on a serial terminal  \nwith hexadecimal display\nWhen the SW2 pushbutton is pressed, the current data is incremented by 1  \nWith every press on SW2 the current position is incremented as well as the  \ncurrent address. This allows us to change the memory contents and check  \nthat the dump has also changed\n');
gettext('## Increment and write  \n\nThe incremented data at the current position is  \nwritten in memory and the current address is also  \nincremented');
gettext('## Machine 1: Dump  \n\nRead the whole memory, sending the byte of  \nthe current position to the serial port');
gettext('4-bits count machine');
gettext('The dump machine is active');
gettext('The byte to transmit is ready one  \ncycle later after the address is set\n');
gettext('Display the current memory output  \non the LEDs');
gettext('It is only used in the  \nincrement mode');
gettext('Incremented byte');
gettext('Byte to sent to  \nthe PC (dump mode)\n');
gettext('In dump mode, the memory output is  \nconnected to the serial transmitter.  \nOtherwise it is incremented\n');
gettext('In dump mode the memory is accessed through  \nmachine 1. Otherwise it is accedded by addr0');
gettext('25-1-Memory-map-6bits-ROM');
gettext('Componente genérico');
gettext('8 Virtual Switches. Receiving unit');
gettext('Separador de bus de 8-bits en 2 buses de 2 y 6 bits');
gettext('Comparador de igualdad, de un operando de 2 bits');
gettext('Separador de bus de 6-bits en uno de 2 y otro de 4bits');
gettext('Habilitación de bus de 8 bits');
gettext('## Example 25-1: Memory map: ROM\n\n| Address   | Resource    |   Type     |\n|-----------|-------------|------------|\n| 0x00-0x0F | ROM memory  | read only  |');
gettext('16B ROM Memory  \n(Read only)');
gettext('## ROM');
gettext('There is an access to the ROM  \nif the two most significant bits  \nof the address are 0 (block 0)\n');
gettext('Dirección de la rom');
gettext('ROM is read only:  \nWrite is always 0');
gettext('Nothing can be written  \nto the ROM: no data input');
gettext('Decompose the address into its  \nblock number (2 bits) and the  \naddress inside the bloque (4 bits)\n(offset)');
gettext('If the access is to the ROM,  \nreturn the data. Otherwise the  \nvalue is 0');
gettext('### Web panel');
gettext('### Dirección de acceso');
gettext('### Dato de entrada');
gettext('Grabar el dato');
gettext('### Salida de la memoria');
gettext('# Switchx8-RX\n\nReceives the state of four virtual Inputs');
gettext('25-2-Memory-map-6bits-ROM-RAM');
gettext('Comparador de igualdad, de un operando de 3 bits');
gettext('## Example 25-2: Memory map: ROM, RAM\n\n| Address   | Resource    |   Type     |\n|-----------|-------------|------------|\n| 0x00-0x0F | ROM memory  | read only  |\n| 0x10-0x17 | RAM memory  | read/write |');
gettext('ROM address');
gettext('## RAM');
gettext('Thereis an access to the RAM if the  \nthree more signficant bits of the  \naddress are equal to 010  \n(Block 1, bottom half)');
gettext('The write is only done if the RAM is selected  \nand there is a pulse in write');
gettext('RAM address');
gettext('Access to a valid zon  \nof the map');
gettext('2 to 1 code');
gettext('## CODER\n\nSel indicates which resource is the one to access\n0: ROM, 1: RAM  \n\nThe access is only valid if the valid signal is 1.  \nOtherwise the access is to a not used zone\n');
gettext('## OUTPUT MULTIPLEXER \n\nIt returns the data read in the accessed zone.  \nIt returns 0 in case the access is to an unused zone\n');
gettext('8bits 2-1 Multiplexer');
gettext('Enable the output,  \naccording to the valid  \nsignal\n');
gettext('25-3-Memory-map-6bits-ROM-RAM-OUTP');
gettext('Comparador de un operando de 6 bits. Se compara si el operando es igual al parámetro');
gettext('Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad');
gettext('## Example 25-3: Memory map: ROM, RAM and output port\n\n| Address   | Resource    |   Type     |\n|-----------|-------------|------------|\n| 0x00-0x0F | ROM memory  | read only  |\n| 0x10-0x17 | RAM memory  | read/write |\n| 0x20      | Output port | read/write |\n');
gettext('4-2 coder');
gettext('## CODER  \n\nSel indicates which resource is the one to access  \n0: ROM, 1: RAM, 2: Output port  \nThe access is only valid if the valid signal is 1  \nOtherwise the access is to a not used zone');
gettext('8-bits 4-1 Multiplexor');
gettext('Output port  \n(Read/Write)');
gettext('## OUTPUT PORT');
gettext('It is selected when the address  \nis 0x20');
gettext('The data is written only when  \nthe is an access to the 0x20 address  \nand there is a pulse in write\n');
gettext('The port value is written to  \nthis 8-bits register\n');
gettext('8B RAM memory  \n(Read/Write)');
gettext('25-4-Memory-map-6bits-ROM-RAM-OUTP-INP');
gettext('### Panel Web');
gettext('## Example 25-4: Memory map: ROM, RAM, Output port and Input port\n\n| Address   | Resource    |   Type     |\n|-----------|-------------|------------|\n| 0x00-0x0F | ROM memory  | read only  |\n| 0x10-0x17 | RAM memory  | read/write |\n| 0x20      | Output port | read/write |\n| 0x21      | Input port  | write only |\n');
gettext('Input port  \n(Read only)');
gettext('## INPUT PORT');
gettext('The data captured from outside  \nis stored in the 8-bits register\n');
gettext('### Inputs\n\nThe two pushbuttons are read in the input port  \nas the two least significant bits. The rest of  \nthe bits are read as 0\n');
gettext('## CODER  \n\nSel indicates which resource is the one to access  \n0: ROM, 1: RAM, 2: Output port, 3: Input port  \nThe access is only valid if the valid signal is 1  \nOtherwise the access is to a not used zone');
gettext('8-bits 4-1 Multiplexer');
gettext('It is selected when the  \naddress is 0x21');
gettext('25-Memory-map-6bits');
gettext('06-bits memory map with ROM, RAM, one input port and one output port');
gettext('### Memory Map');
gettext('Output port');
gettext('Input port');
gettext('### Inputs\n\nThe two pushbuttons can be read in the input  \nport: bits 0 and 1. The rest of the bits are  \nread as 0');
gettext('## Example 25: Accesing the memory map from a web panel\n\nFrom the web panel the 6-bits address is enter. All positions are 8 bits    \nThe memory map has the following organization:  \n\n| Address   | Resource    |   Type     |\n|-----------|-------------|------------|\n| 0x00-0x0F | ROM memory  | read only  |\n| 0x10-0x17 | RAM memory  | read/write |\n| 0x20      | Output port | read/write |\n| 0x21      | Input port  | write only |\n\nThe LEDs are connected to the oputput port  \nThe pushbuttons SW1 and SW1 can be read in  \nthe bits 1 and 0 of the input port  \n');
gettext('## Youtube Video\n\n[Link](https://www.youtube.com/watch?v=c_NIoVIzPew)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/c_NIoVIzPew/0.jpg)](https://www.youtube.com/watch?v=c_NIoVIzPew)');
gettext('## Web panel for testing\n\nFor testing this example upload it to the  \nFPGA and connect to the [Test WEB panel](https://fpgawars.github.io/LOVE-FPGA/Releases/v0.1.0/CT9/panel.html)  \n(You should use a Browser that support **Webserial**, like **Chromium** or **Chrome**)  \nYou do not need to install anything. Just the browser\n\n[Panel Image](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/map-io-04.png)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT9-Memorias/map-io-04.png)');
gettext('Memoria ROM 16B  \n(Sólo lectura)');
gettext('Memoria RAM 8B  \n(Lectura/escritura)');
gettext('Puerto de Salida  \n(Lectura/escritura)');
gettext('Puerto de Entrada  \n(Sólo lectura)');
gettext('Se está accediendo a la rom cuando  \nlos dos bits de mayor peso de la  \ndirección son iguales a 0  \n(Bloque 0)');
gettext('La ROM es de solo escritura:  \nLa señal write siempre a 0');
gettext('No se escribe nada  \nen la rom: NO hay dato  \nde entrada');
gettext('Se está accediendo a la RAM cuando  \nlos tres bits de mayor peso de la  \ndirección son iguales a 010  \n(Bloque 1, mitad inferior)');
gettext('La escritura se realiza si está seleccionada  \nla memoria RAM y llega un pulso en write');
gettext('Dirección de la ram');
gettext('## PUERTO DE SALIDA');
gettext('Se selecciona cuando la  \ndirección es la 0x20');
gettext('Sólo se hace la escritura cuando  \nse accede a la dirección 0x20  \ny llega el pulso en write');
gettext('El valor del puerto se guarda  \nen este registro de 8 bits');
gettext('## PUERTO DE ENTRADA');
gettext('El valor capturado del exterior  \nse almacena en este registro  \nde 8 bits');
gettext('Se selecciona cuando la  \ndirección es la 0x21');
gettext('## CODIFICADOR  \n\nSe indica en Sel cuál es el recurso al que se  \nquiere acceder:  \n0: ROM, 1: RAM, 2: Puerto salida, 3: Puerto entraeda  \nSiempre y cuando la señal valid sea 1. Si es valid = 0,  \nsignifica que se accede a una zona no usada');
gettext('## MULTIPLEXOR DE SALIDA \n\nDevuelve el dato leido en la zona accedida.  Siempre  \nque se accede a una zona NO usada, se devuelve 0');
gettext('Se accede a una zona  \nválida del mapa');
gettext('Codificador 4 a 1');
gettext('Multiplexor de 4 a 1  \nde 8 bits');
gettext('Habilitar o no  \nla salida, según la  \nseñal valid');
gettext('Valor del puerto de salida');
gettext('Dato leído del  \nmapa de memoria');
gettext('## Mapa de memoria de ejemplo de 6 bits\n\nEl mapa tiene la siguiente organización:\n\n| Dirección | Recursos | Tipo |\n|-----------|----------|------|\n| 0x00-0x0F | Memoria ROM | Sólo lectura |\n| 0x10-0x17 | Memoria RAM | Lectura/Escritura |\n| 0x20      | Puerto de salida | Lectura/Escritura |\n| 0x21      | Puerto de entrada| Solo lectura  |\n');
gettext('Banks');
gettext('Machines');
gettext('Regs');
gettext('SMem');
gettext('SMem-bus');
gettext('01-bit');
gettext('08-bits');
gettext('Bank-2x1');
gettext('Bank-4x1');
gettext('Bank-8x1');
gettext('Reg-automatic-test');
gettext('Comparador de dos operandos de 1 bit');
gettext('Multiplicador de cables. Genera un bus de 8 bits, a patir del bit de entrada');
gettext('Circuito combinacional de 4 entradas y 4 salidas');
gettext('start: Start signal: It goes from 1 to 0 when the system clock starts. 1 cycle pulse witch. Block implementation');
gettext('Print a constant string of 15 or less characters');
gettext('Baliza luminosa de 1 led. Parpadea a 2Hz cuando se activa');
gettext('Simplified-Heart-Hz-sys-32bits: periodic signal in Hertz. Duty cicle of 50 percent');
gettext('SR1-32bits: Shift  a 32-bit value one bit right. MSB is filled with the input  in');
gettext('Bus32-Split-31-1: Split the 32-bits bus into two buses of 31 and 1 wires');
gettext('Bus32-Join-1-31: Join the two buses into an 32-bits Bus');
gettext('Unit-hz-32bits: hz to cycles converter');
gettext('Heart-sys-zero-32bits: Generate a periodic signal of period T cycles. It starts at cycle 0. It never stops');
gettext('Secuencia del coche fantástico, con entrada de enable');
gettext('Corazón de bombeo de tics con periodo paramétrico de milisegundos y entrada de enable');
gettext('# Bank 2x1: Automatic testing\n');
gettext('## Unit under test');
gettext('## Verification table');
gettext('Compare the current output with the  \ncorrect value from the table');
gettext('0: Current test NOT passed  \n1: Current test passed! OK!');
gettext('ERROR state:  \n0: No error so far  \n1: At least one test NOT passed');
gettext('Test finished');
gettext('The end-tic is sent to one  \ncircuit or another depending  \non the error state');
gettext('## SUCESS!!');
gettext('##  ERROR. Tests NOT passed!!');
gettext('## The result is printed on the Console');
gettext('2x1 register Bank');
gettext('Initial value: 1');
gettext('Initial value: 0');
gettext('Falling edge');
gettext('**Baliza luminosa**\n\nParpadeo del LED a 2Hz');
gettext('Dividir entre dos el periodo  \n(Multiplicar por 2 la frecuencia)  ');
gettext('Delay');
gettext('Start a new period');
gettext('Start at cycle 0!');
gettext('Repeat!');
gettext('Current period ended  \nStart a new one');
gettext('Periodo (in system clock cycles)');
gettext('Current cycle in the period  \n(0-T-1)');
gettext('Reg-manual-test');
gettext('Button-tic: Configurable button that emits a tic when it is pressed');
gettext('Configurable button (pull-up on/off. Not on/off)');
gettext('FPGA internal pull-up configuration on the input port');
gettext('Select positive or negative logic for the input (0=positive, 1=negative)');
gettext('Edges detector. It generates a 1-period pulse (tic) when either a rising edge or a falling edge is detected on the input. Block implementation');
gettext('16-bits Syscounter with reset');
gettext('Inc1-16bit: Increment a 16-bits number by one');
gettext('AdderK-16bit: Adder of 16-bit operand and 16-bit constant');
gettext('Generic: 16-bits generic constant');
gettext('Adder-16bits: Adder of two operands of 16 bits');
gettext('16-Sys-reg-rst: 16 bits system register with reset. Verilog implementation');
gettext('Sync-x01: 1-bit input with the system clock domain (Verilog implementation)');
gettext('## Bank-2x1: Manual testing\n\nUse Switch 1 for setting the input data (0/1)  \nUse Switch 2 for setting the address (0/1)\nLong press on Switch 1 for writing the data to the current register\n');
gettext('Data to store  \n(0/1)');
gettext('Address (0/1)');
gettext('Show the current  \nregister in LED0');
gettext('Show the data in  \nLED5');
gettext('Show the current  \naddr in LED7');
gettext('Long click');
gettext('Normal click');
gettext('Button state signal');
gettext('Tic: button pressed');
gettext('Rising edge detector');
gettext('Pull up on/off');
gettext('Not on/off');
gettext('Internal pull-up  \n* 0: OFF\n* 1: ON');
gettext('Synchronization stage');
gettext('Normalization stage\n\n* 0: Wire\n* 1: signal inverted');
gettext('Debouncing stage');
gettext('### Pull-up parameter:\n\n0: No pull-up  \n1: Pull-up activated');
gettext('Only an FPGA pin can  \nbe connected here!!!');
gettext('The pull-up is connected  \nby default');
gettext('When k=0, it works like a wire  \n(The output is equal to the input)  \nWhen k=1, it act as a not gate\n(The output is the inverse of the input)');
gettext('### Truth table for XOR\n\n| k | input | output | function |\n|---|-------|--------|----------|\n| 0 | 0     |  0     | wire     |\n| 0 | 1     |  1     | wire     |\n| 1 | 0     |  1     | Not      |\n| 1 | 1     |  0     | Not      |');
gettext('Edge detector');
gettext('Whenever there is a change in  \nthe input, the counter is started');
gettext('If the counter reaches it maximum  \nvalue, the input is considered stable  \nand it is captured');
gettext('### Time calculation\n\nFor CLK=12MHZ, a 16-bit counter reaches its  \nmaximum every 2 ** 16 * 1/F = 5.5ms aprox  \nIF more time is needed for debouncing,  \nuse a counter with more bits (17, 18...)');
gettext('## Debouncer  \n\nA value is considered stable when  \nthere is no changes during 5.5ms  \naprox. When a value is stable it is  \ncaptured on the output flip-flop');
gettext('Stable output');
gettext('Counter');
gettext('## Edges detector\n\nIt generates a 1-period pulse (tic) when an edge (Rising or falling) is detected on the  \ninput signal');
gettext('The output is 1 if the current value is 1 and the  \nprevious 0, or if the current value is 0 and the  \nprevious 1\n');
gettext('In any other case the output is 0');
gettext('## Timeout-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Paralell-Reg-manual-test');
gettext('## Bank-4x1-paralell: Manual testing\n\nUse SW1 for toggle the data stored on the current register  \nUse SW2 for selecting the register address (0-3)  \n');
gettext('Address (0-3)');
gettext('4x1 register Bank');
gettext('Show the current  \naddr in LEDs 7 and 6');
gettext('The data to be written is  \nthe current data negated');
gettext('Toggle the current  \ndata');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 5 entradas y 5 salidas');
gettext('Print a base4 number in Binary');
gettext('# Bank 4x1: Automatic testing\n');
gettext('Print the current  \nbit');
gettext('Base 4 number to print');
gettext('Reg-manual-test');
gettext('## Bank-4x1: Manual testing\n\nUse SW1 for setting the data to write (0/1)  \nUse SW2 for selecting the register address (0-3)  \nUse a Long click in SW1 to write the data into the current reg\n');
gettext('Show the data in  \nLED4');
gettext('Paralell-Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Paralell-Reg-manual-test');
gettext('Counter-x03: 3-bits counter');
gettext('Inc1-3bit: Increment a 3-bits number by one');
gettext('AdderK-3bit: Adder of 3-bit operand and 3-bit constant');
gettext('Adder-3bits: Adder of two operands of 3 bits');
gettext('Bus3-Split-all: Split the 3-bits bus into three wires');
gettext('Bus3-Join-all: Joint three wires into a 3-bits Bus');
gettext('03-Reg: 3 bits Register. Verilog implementation');
gettext('## Bank-8x1-paralell: Manual testing\n\nThe whole bank registers are shown in the 8 LEDs  \nWith the SW1 button, the content of the current reg is toggled  \nWith the sW2 button, the addres is increased  \nThis simple mechanism allows you to change all the register and  \ncheck that the bank is working properly\n\n');
gettext('8x1 register Bank');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 6 entradas y 6 salidas');
gettext('Print a 3-bits number in Binary');
gettext('03-SL-ld: 3 bits shift left register with load. Verilog implementation');
gettext('Máquina de contar, de 6 bits');
gettext('# Bank 8x1: Automatic testing\n');
gettext('First the MSB is  \nprinter');
gettext('## Print-bin-3-bits: Transmit one 3-bits number in Binary\n\nWhen activated, the 3-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Reg-manual-test');
gettext('## Bank-8x1: Manual testing\n\nUse SW1 for toggling the current register (writing)  \nUse SW2 for selecting the register address (0-7)');
gettext('Addres (0-7)');
gettext('Show the current  \nreg in the LED0');
gettext('Show the current  \naddress in the LEDs');
gettext('Toggle the current reg');
gettext('Paralell-Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Bank-2x8');
gettext('Bank-4x8');
gettext('Bank-8x8');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 4 entradas y 18 salidas');
gettext('Split a 18 bits bus into two of  1 and 17 bits buses');
gettext('Split a 17 bits bus into two of  8 and 9 bits buses');
gettext('Separador de bus de 9-bits en uno de 1bit y otro de 8bits');
gettext('Comparador de dos operandos de 8 bits');
gettext('Print a 8-bits number in Binary');
gettext('08-SL-ld: 8 bits shift left register with load. Verilog implementation');
gettext('# Bank 2x8: Automatic testing\n');
gettext('2x8 register Bank');
gettext('state machine  \n');
gettext('## Print-bin-8-bits: Transmit one 8-bits number in Binary\n\nWhen activated, the 8-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Reg-manual-test');
gettext('Circuito combinacional de 3 entradas y 8 salidas');
gettext('## Bank-2x8: Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current register  \nUse Switch 2 for setting the address (0/1)\n');
gettext('Data to store  ');
gettext('Show the current  \nregister in the LEDs');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 5 entradas y 19 salidas');
gettext('Split a 19 bits bus into two of  2 and 17 bits buses');
gettext('# Bank 4x8: Automatic testing\n');
gettext('4x8 register Bank');
gettext('Reg-manual-test');
gettext('## Bank-4x8: Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current register  \nUse Switch 2 for setting the address (0-3)\n');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 6 entradas y 20 salidas');
gettext('Split a 20-bit bus into one of 3-bits and another of 17-bits');
gettext('# Bank 8x8: Automatic testing\n');
gettext('8x8 register Bank');
gettext('Reg-manual-test');
gettext('## Bank-8x8: Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current register  \nUse Switch 2 for setting the address (0-7)\n');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Bytes');
gettext('002B');
gettext('004B');
gettext('008B');
gettext('016B');
gettext('01-seq-leds');
gettext('# Testing the Seq machine  \n\nWhen the button is pressed, the contents of  \nthe memory are displayed in the leds,  \nsequentially, starting from the 0 address  \n\nThe time between values is 400 ms');
gettext('Press the button for  \nstarting the sequence on  \nthe LEDs  ');
gettext('02-seq-inf-leds');
gettext('# Testing the Seq-inf machine  \n\nWhen the button is pressed, the contents of  \nthe memory are displayed in the leds,  \nsequentially, starting from the 0 address  \n\nThe time between values is 400 ms');
gettext('03-init-seq-leds');
gettext('# Testing the Init machine  \n\nThe button 1 is used for showing the memory  \ncontents in the LEDs (sequencially)  \nPressing the button 2 fill the memory with  \nconsecutive numbers starting from the init  \nvalue');
gettext('04-dump');
gettext('# Testing the dump machine  \n\nWhen the sw1 button is pressed, the memory content  \nis dumped to the serial console');
gettext('Press the button for  \ndumping the memory');
gettext('05-dump-tx');
gettext('# Testing the dump-tx machine  \n\nWhen the sw1 button is pressed, the memory content  \nis dumped to the serial console\n\nUse long press on buttons 1 or 2 to change the  \nmemory contents');
gettext('Click on the button 1 for  \ndumping the memory');
gettext('Long click on Button 1  \nfor init the memory with  \nvalue 1');
gettext('Long click on Button 2  \nfor init the memory with  \nvalue 2');
gettext('06-upload-dump');
gettext('Lectura de caracteres de entrada a traves de entrada serie');
gettext('stdin bus joiner (data + tic)');
gettext('# Testing the upload machine  \n\nWhen the button 1 is pressed, the memory is printed  \non the serial control  \nWhen the button 2 is pressed, the upload mode is  \nentered. The led7 is on and all the bytes received  \nfrom the serial console are written into memory  \nsequentially  \nOne the memory has been uploaded it will be automatically  \nbe printed on the serial console');
gettext('Use Button 1 for printing\nthe memory contents');
gettext('Use Button 2 for uploading data  \nto the memory, from the serial console');
gettext('The memory is dumped either when the  \nupload machine is done (automatic dump)  \nor when the Button 1 is pressed (Manual dump)');
gettext('## STDIN serial\n\nSerial receiver for the STDIN bus\n');
gettext('**STDIN Bus**  \n* Data received (8 bits)  \n* tic (1 bit)');
gettext('07-test-acc-dump-tx');
gettext('# Testing the test-acc machine  \n\nUse the sw1 button for dumping the memory  \nUse the sw2 button for executing the operation:  \n* M0 = M0 + M1  \n\nwhere M0 and M1 are the bytes located at address 0 and  \n1 respectivelly');
gettext('Use Button 1 for printing\nthe memory in the contents');
gettext('Use Button 2 for executing  \nthe operation M0 = M0 + M1');
gettext('Operation:  \n* M0 = M0 + M1');
gettext('08-upload-test-acc-dump');
gettext('# Testing the upload machine  \n\nUse a long click on button 2 for uploading data into  \nthe memory. A click on button 2 will perform the operation:  \nM0 = M0 + M1  \nPressing button 1 will print the memory contents on the  \nconsole  ');
gettext('Use Button 2 for performing the operation  \nM0 = M0 + M1');
gettext('Use a long click on Button 2 for uploading  \ndata into the memory');
gettext('09-upload-proto-dump-tx');
gettext('10-sample-seq-leds');
gettext('8-bits Syscounter with reset');
gettext('Inc1-8bit: Increment a 8-bits number by one');
gettext('AdderK-8bit: Adder of 8-bit operand and 8-bit constant');
gettext('08-Sys-reg-rst: 8 bits system register with reset. Verilog implementation');
gettext('# Testing the sample machine  \n\nWhen the sw1 button is pressed, the memory content  \nis dumped to the LEDs.  \nWhen the sw2 button is pressed, the free running  \ncounter is captured and store into the memory');
gettext('11-browse-sample-leds');
gettext('# Testing the browse machine  \n\nThe current memory is shown in the LEDs  \nWhen the sw1 button is pressed, the address is increased  \nWhen the sw2 button is pressed, the browse machine is stoped,  \nthe sample machine started and the browse started again\n');
gettext('12-download');
gettext('# Testing the download machine  \n\nWhen the sw1 button is pressed, the memory is dumped to the  \nserial port\n');
gettext('13-icerok-probe');
gettext('# Testing the icerok-probe machine\n\nA 8 bits counter is running. It is incremented on  \nevery system clock pulse. When the button 1 is  \npressed, the data capturing is enable. The data is  \nrecorded into the memory and sent to the PC  \nby serial port (raw data)\n\nAn application in the computer reads the data  \n(it can be the icerok icestudio plugin or any other  \nprogram)');
gettext('Free running  \n8-bit counter');
gettext('Use the sw1 button for  \nstaring the capturing of  \nthe data (on every system  \nclock cycle)');
gettext('13-icerok-probe');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('# Testing the sum machine  \n\nUse the sw1 button for dumping the memory  \nUse the sw2 button for executing the operation:  \n* M0 = M1 + M2 + M3  \n\nwhere Mx is the byte located at address x ');
gettext('07-upload-dump');
gettext('08-upload-test-acc-dump');
gettext('09-upload-sum-dump');
gettext('# Testing the upload machine  \n\nUse a long click on button 2 for uploading data into  \nthe memory. A click on button 2 will perform the operation:  \nM0 = M1 + M2 + M3  \nPressing button 1 will print the memory contents on the  \nconsole  ');
gettext('Operation:  \n* M0 = M1 + M2 + M3');
gettext('10-sample-download');
gettext('## Testing the Sample and Download memory machines\n\nWhen the SW1 is pressed, the free running counter is sampled  \nand then dumped to the serial port');
gettext('11-icerok-probe');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('07-upload-dump');
gettext('08-upload-test-acc-dump');
gettext('09-upload-sum-dump');
gettext('10-icerok-probe');
gettext('10-sample-download');
gettext('11-icerok-probe');
gettext('11-sample-download');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('# Testing the sum machine  \n\nUse the sw1 button for dumping the memory  \nUse the sw2 button for executing the operation:  \n* M0 = M1 + M2 + .. + M7  \n\nwhere Mx is the byte located at address x ');
gettext('Use Button 2 for executing  \nthe operation');
gettext('07-upload-dump');
gettext('08-upload-sum-dump');
gettext('# Testing the upload machine  \n\nUse a long click on button 2 for uploading data into  \nthe memory. A click on button 2 will perform the operation:  \nM0 = M1 + M2 + .. + M7  \nPressing button 1 will print the memory contents on the  \nconsole  ');
gettext('Use Button 2 for performing the operation  \n');
gettext('09-icerok-probe');
gettext('Contador del sistema, de 8 bits');
gettext('Valor constante 0 para bus de 3 bits');
gettext('Valor genérico constante, de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Multiplexor de 2 a 1 de 13 bits');
gettext('09-sample-download');
gettext('10-icerok-probe');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('07-upload-dump');
gettext('08-upload-sum-dump');
gettext('09-icerok-probe');
gettext('09-sample-download');
gettext('10-icerok-probe');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('# Testing the sum machine  \n\nUse the sw1 button for dumping the memory  \nUse the sw2 button for executing the operation:  \n* M0 = M1 + M2 + .. + M15  \n\nwhere Mx is the byte located at address x ');
gettext('07-upload-dump');
gettext('08-upload-sum-dump');
gettext('09-sample-download');
gettext('10-icerok-probe');
gettext('01-seq-leds');
gettext('02-init-seq-leds');
gettext('03-dump');
gettext('04-dump-tx');
gettext('05-test-acc-dump-tx');
gettext('06-sum-dump-tx');
gettext('07-upload-dump');
gettext('08-upload-sum-dump');
gettext('09-icerok-probe');
gettext('09-sample-download');
gettext('10-icerok-probe');
gettext('01-bit');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('08-bits');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 3 entradas y 3 salidas');
gettext('Print a constant string of 31 or less characters');
gettext('Máquina de contar, de 5 bits, con entrada de stop');
gettext('# 1-bit register: Automatic testing\n');
gettext('Reg-manual-test');
gettext('## 1-bit register: Manual testing\n\nUse Switch 1 for setting the input data (0/1)  \nUse Swtich 2 for capturing the data');
gettext('Show the register  \nin the LED0\n');
gettext('Select the input bit  \n(0/1)');
gettext('This bit is shown in  \nLED7');
gettext('Use this pushbutton  \nfor loading the data  \ninto the register');
gettext('Reg-rst-automatic-test');
gettext('DFF-rst. D Flip-Flop with load and reset. Implemented in verilog');
gettext('# 1-bit register with reset: Automatic testing\n');
gettext('Reg-rst-manual-test');
gettext('## 1-bit register with reset: Manual testing\n\nUse Switch 1 for setting the input data (0/1)  \nUse Swtich 2 for capturing the data  \nUse a long press on Switch 1 for reseting');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-rst-automatic-test');
gettext('Reg-rst-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 4 entradas y 5 salidas');
gettext('# 2-bits register: Automatic testing\n');
gettext('2 Bits register');
gettext('Reg-manual-test');
gettext('Counter: Data to be    \ncaptured in the register');
gettext('Select the input  \ndata (0,1,2,4)');
gettext('## 2-bits register: Manual testing\n\nUse Switch 1 for setting the input data (0,1,2,3)  \nUse Swtich 2 for capturing the data');
gettext('2-Bits register');
gettext('Show the register  \nin the LEDs \n');
gettext('Show the input  \nin the LEDs\n');
gettext('Reg-rst-automatic-test');
gettext('# 2-bits register with reset: Automatic testing\n');
gettext('Reg-rst-manual-test');
gettext('## 2-bits register with reset: Manual testing\n\nUse Switch 1 for setting the input data (0,1,2,3)  \nUse Swtich 2 for capturing the data');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-rst-automatic-test');
gettext('Reg-rst-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 4 entradas y 7 salidas');
gettext('Separador de bus de 7-bits en dos buses de 3 y 4 bits');
gettext('# 3-bits register: Automatic testing\n');
gettext('3 Bits register');
gettext('Reg-manual-test');
gettext('Select the input  \ndata');
gettext('## 3-bits register: Manual testing\n\nUse Switch 1 for setting the input data (0-7)  \nUse Swtich 2 for capturing the data');
gettext('3-Bits register');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 4 entradas y 9 salidas');
gettext('Spit a 9-bits bus into 4-bits and 5-bits buses');
gettext('Split a 5-bits bus into 1-bit and 4-bits buses');
gettext('04-Reg: 4 bits Register. Verilog implementation');
gettext('Print a 4-bits number in Binary');
gettext('04-SL-ld: 4 bits shift left register with load. Verilog implementation');
gettext('# 4-bits register: Automatic testing\n');
gettext('4 Bits register');
gettext('## Print-bin-4-bits: Transmit one 4-bits number in Binary\n\nWhen activated, the 4-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Reg-manual-test');
gettext('Counter-x04: 4-bits counter');
gettext('Inc1-4bit: Increment a 4-bits number by one');
gettext('AdderK-4bit: Adder of 4-bit operand and 4-bit constant');
gettext('## 4-bits register: Manual testing\n\nUse Switch 1 for setting the input data (0-15)  \nUse Swtich 2 for capturing the data');
gettext('4-Bits register');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Reg-automatic-test');
gettext('Circuito combinacional de 5 entradas y 17 salidas');
gettext('# 8-bits register: Automatic testing\n');
gettext('8 Bits register');
gettext('Reg-manual-test');
gettext('Counter-x08: 8-bits counter');
gettext('## 8-bits register: Manual testing\n\nUse Switch 1 for setting the input data (0-255)  \nUse Switch 2 for capturing the data');
gettext('8-Bits register');
gettext('Reg-automatic-test');
gettext('Reg-manual-test');
gettext('Bytes');
gettext('KiB');
gettext('Bytes');
gettext('002B');
gettext('004B');
gettext('008B');
gettext('016B');
gettext('dump-leds');
gettext('Simplified-Heart-ms-sys-32bits: Nominal periodic signal in mili seconds');
gettext('dump-leds');
gettext('dump-leds');
gettext('Simplified-Heart-tic-ms-sys-32bits: Nominal periodic signal in mili seconds');
gettext('dump-leds');
gettext('dump-leds');
gettext('dump-leds');
gettext('dump-leds');
gettext('dump-leds');
gettext('002B');
gettext('004B');
gettext('008B');
gettext('016B');
gettext('032B');
gettext('064B');
gettext('128B');
gettext('256B');
gettext('512B');
gettext('Smem-automatic-test');
gettext('# 2B Memory (2x8): Automatic testing\n');
gettext('2B Memory');
gettext('Read the memory output in  \nthe next cycle');
gettext('Smem-manual-test');
gettext('## Sync memory 2B (2x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0/1)\n');
gettext('2Bytes memory');
gettext('Show the current  \nposition in the LEDs');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('# 4B Memory (4x8): Automatic testing\n');
gettext('4B Memory');
gettext('Smem-manual-test');
gettext('## Sync memory 4B (4x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0-3)\n');
gettext('4Bytes memory');
gettext('Data selection and  \nwrite');
gettext('Address selection');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('5-bit Constant 0 value');
gettext('Valor genérico constante, de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('# 8B Memory (8x8): Automatic testing\n');
gettext('8B Memory');
gettext('Smem-manual-test');
gettext('## Sync memory 8B (8x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0-7)\n');
gettext('8Bytes memory');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('Mach-count-4-bits: 4-bits count machine');
gettext('OR-BUS4-verilog: OR gate with 4-bits bus input. Verilog implementation');
gettext('Display the Testbench result on the LEDs');
gettext('Test value to write at the current  \nmemory position: addr + seed,  \nDuring the writting stage');
gettext('Compare the data written during the first  \nstage with the actual memory content  \nThey should be equal');
gettext('## Memory Under Test');
gettext('The write command should be valid  \nonly when the machine is running');
gettext('Print the table header  \ninitially');
gettext('## 1-bit Count Machine\n\nThere are two stages:\n\n* Stage 0: Writting stage\n* Stage 1: Reading and checking stage');
gettext('### 4-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Stage 0: move to the next address');
gettext('Stage 1: Print the result');
gettext('Print the address');
gettext('Print the Data');
gettext('Move to the next  \naddress');
gettext('## Display a sequence in the LEDs');
gettext('# 16B Memory (16x8): Automatic testing\n');
gettext('### SUCESS animation');
gettext('### Test not passed');
gettext('Sequence state: on/off');
gettext('The \"Knight rider\" sequence  \non the LEDs');
gettext('Blink all the leds at the  \nsame time');
gettext('Smem-manual-test');
gettext('## Sync memory 16B (16x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0-15)\n');
gettext('16Bytes memory');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('Create an 8-bit bus from two buses of 3 and 5 bits');
gettext('05-Uint08: 5 bits unsigned integer extension to 8 bits. Verilog implementation');
gettext('# 32B Memory (32x8): Automatic testing\n');
gettext('### 5-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-manual-test');
gettext('Counter-x05: 5-bits counter');
gettext('Inc1-5bit: Increment a 5-bits number by one');
gettext('AdderK-5bit: Adder of 5-bit operand and 5-bit constant');
gettext('Adder-5bits: Adder of two operands of 5 bits');
gettext('Bus5-Split-1-4: Split the 5-bits bus into two buses of 1 and 4 bits');
gettext('Bus5-Join-1-4: Join the two buses of 1 and 4 bits into a 5-bits Bus');
gettext('05-Reg: 5 bits Register. Verilog implementation');
gettext('## Sync memory 32B (32x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0-15)\n');
gettext('32Bytes memory');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('Agregador de 2 buses de 2 y 6-bits a bus de 8-bits');
gettext('06-Uint08: 6 bits unsigned integer extension to 8 bits. Verilog implementation');
gettext('# 64B Memory (64x8): Automatic testing\n');
gettext('### 6-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-manual-test');
gettext('Contador módulo M, ascendente, de 6 bits, con reset ');
gettext('## Sync memory 64B (64x8): Manual testing\n\nUse Switch 1 for setting the input data (it is selected from the table)   \n and writting it to the current position  \nUse Switch 2 for setting the address (0-15)\n');
gettext('64Bytes memory');
gettext('Smem-automatic-test');
gettext('Smem-manual-test');
gettext('Smem-automatic-test');
gettext('Agregador de 1 cable y un bus de 7-bits a bus de 8-bits');
gettext('Máquina de contar, de 7 bits');
gettext('7-bits adder. One operand is a constant (no carry)');
gettext('two operand 7-bits comparator');
gettext('Valor genérico constante (menos 1), de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('07-Reg-rst: 7 bits Register with reset. Verilog implementation');
gettext('# 128B Memory (128x8): Automatic testing\n');
gettext('### 7-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Máquina de contar, de 8 bits');
gettext('Valor genérico constante (menos 1), de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('# 256B Memory (256x8): Automatic testing\n');
gettext('### 8-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Sumador de un operando de 9 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Print a 12-bit number in hexadecimal numbers');
gettext('Split the 12-bit bus into a 3 buses of 4-bits ');
gettext('Multiplexor de 4 a 1 de 4 bits');
gettext('12-Reg: 12 bits Register. Verilog implementation');
gettext('09-Uint12: 9 bits unsigned integer extension to 12 bits. Verilog implementation');
gettext('Máquina de contar, de 9 bits');
gettext('Two 9-bit operands comparator');
gettext('Valor genérico constante (menos 1), de 9 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('09-Reg-rst: 9 bits Register with reset. Verilog implementation');
gettext('# 512B Memory (512x8): Automatic testing\n');
gettext('## Print-hex-12: Print a 12-bit number in hexadecimal');
gettext('Smem-automatic-test');
gettext('01KiB');
gettext('02KiB');
gettext('04KiB');
gettext('08KiB');
gettext('16KiB');
gettext('Smem-automatic-test');
gettext('Sumador de un operando de 10 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Split the 10-bit bus into a 2-bits bus and a 8-bits bus');
gettext('Join an 2-bit bus and a 10-bit bus into a 12-bits bus');
gettext('Máquina de contar, de 12 bits');
gettext('Sumador de un operando de 12 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Valor genérico constante (menos 1), de 12 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Comparador de dos operandos de 12 bits');
gettext('12-Reg-rst: 12 bits Register with reset. Verilog implementation');
gettext('Bus12-Split-2-10: Split the 12-bits bus into two buses of 2 and 10 wires');
gettext('# 1KiB Memory (1024x8): Automatic testing\n');
gettext('### 10-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Sumador de un operando de 11 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Split the 11-bit bus into a 3-bits bus and a 8-bits bus');
gettext('11-Uint12: 11 bits unsigned integer extension to 12 bits. Verilog implementation');
gettext('Bus12-Split-1-11: Split the 12-bits bus into two buses of 1 and 11 wires');
gettext('# 2KiB Memory (2048x8): Automatic testing\n');
gettext('### 11-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Split the 12-bit bus into a 4-bits bus and a 8-bits bus');
gettext('# 4KiB Memory (4096x8): Automatic testing\n');
gettext('### 12-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Sumador de un operando de 13 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Separador de bus de 13-bits en uno de 5bit y otro de 8bits');
gettext('Máquina de contar, de 16 bits');
gettext('Sumador de un operando de 16 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 16 bits');
gettext('Valor genérico constante (menos 1), de 16 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('16-Reg-rst: 16 bits Register with reset. Verilog implementation');
gettext('Bus16-Split-half: Split the 16-bits bus into two buses of 3 and 13 wires');
gettext('Print a 16-bit number in hexadecimal numbers');
gettext('Separador de bus de 16-bits en buses de 8 bits');
gettext('16-Reg: 16 bits Register. Verilog implementation');
gettext('13-Uint16: 13 bits unsigned integer extension to 16 bits. Verilog implementation');
gettext('# 8KiB Memory (8192x8): Automatic testing\n');
gettext('### 13-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('## Print-hex-16: Print a 16-bit number in hexadecimal');
gettext('Smem-automatic-test');
gettext('Smem-automatic-test');
gettext('Separador de bus de 14-bits en uno de 6bit y otro de 8bits');
gettext('Bus16-Split-half: Split the 16-bits bus into two buses of 2 and 14 wires');
gettext('14-Uint16: 14 bits unsigned integer extension to 16 bits. Verilog implementation');
gettext('# 16KiB Memory (16384x8): Automatic testing\n');
gettext('### 14-bits Count Machine\n\nThis machine generates the address  \nfor the memory');
gettext('Smem-automatic-test');
